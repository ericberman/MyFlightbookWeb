using DotNetOpenAuth.OAuth2;
using Dropbox.Api;
using MyFlightbook.Image;
using MyFlightbook.OAuth;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using System.Web;

/******************************************************
 * 
 * Copyright (c) 2016-2024 MyFlightbook LLC
 * Contact myflightbook-at-gmail.com for more information
 *
*******************************************************/

namespace MyFlightbook.CloudStorage
{
    /// <summary>
    /// Specifies the default cloud storage to use for a given user if they've authorized more than one.
    /// </summary>
    public enum StorageID { None, Dropbox, GoogleDrive, OneDrive }

    /// <summary>
    /// Base class for cloud storage
    /// </summary>
    public abstract class CloudStorageBase : OAuthClientBase
    {
        /// <summary>
        /// Creates a cloud storage provider using parameters for oAuth authentication and token retrieval
        /// </summary>
        /// <param name="szAppKeyKey">The LocalConfig key for the oAuth2 appeky</param>
        /// <param name="szAppSecretKey">The LocalConfig key for the oAuth2 secret</param>
        /// <param name="szOAuth2AuthEndpoint">The oAuth2 authorization endpoint URL</param>
        /// <param name="szOAuth2TokenEndpoint">The oAuth2 token endpoint URL</param>
        /// <param name="scopes">Array of scopes for oAuth</param>
        protected CloudStorageBase(string szAppKeyKey, string szAppSecretKey, string szOAuth2AuthEndpoint, string szOAuth2TokenEndpoint, string[] scopes = null, string szUpgradeEndpoint = null, string szDisableEndpoint = null) : 
            base(szAppKeyKey, szAppSecretKey, szOAuth2AuthEndpoint, szOAuth2TokenEndpoint, scopes, szUpgradeEndpoint, szDisableEndpoint)
        {
        }

        public static string CloudStorageName(StorageID sid)
        {
            switch (sid)
            {
                case StorageID.Dropbox:
                    return Resources.LocalizedText.CloudStorageDropbox;
                case StorageID.GoogleDrive:
                    return Resources.LocalizedText.CloudStorageGDrive;
                case StorageID.OneDrive:
                    return Resources.LocalizedText.CloudStorageOneDrive;
                case StorageID.None:
                default:
                    return string.Empty;
            }
        }

        /// <summary>
        /// The current user
        /// </summary>
        protected Profile CurrentUser { get; set; }

        public static bool UserUsesFlatHierarchy(Profile pf)
        {
            return pf != null && pf.GetPreferenceForKey(MFBConstants.keyPrefFlatHierarchy, false);
        }

        public static void SetUsesFlatHierarchy(Profile pf, bool value)
        {
            pf?.SetPreferenceForKey(MFBConstants.keyPrefFlatHierarchy, value, value == false);
        }
    }

    #region Google Drive
    #region Google Drive Errors
#pragma warning disable CA1507 // Use nameof to express symbol names
    /*
     * Generated by Xamasoft JSON Class Generator http://www.xamasoft.com/json-class-generator
     */
    [Serializable]
    public class GoogleDriveInternalError
    {

        [JsonProperty("domain")]
        public string domain { get; set; }

        [JsonProperty("reason")]
        public string reason { get; set; }

        [JsonProperty("message")]
        public string message { get; set; }
    }

    [Serializable]
    public class GoogleDriveError
    {

        [JsonProperty("errors")]
        public Collection<GoogleDriveInternalError> errors { get; private set; }

        [JsonProperty("code")]
        public int code { get; set; }

        [JsonProperty("message")]
        public string message { get; set; }

        public GoogleDriveError()
        {
            errors = new Collection<GoogleDriveInternalError>();
        }
    }
#pragma warning restore CA1507 // Use nameof to express symbol names
    #endregion

    [Serializable]
    public class GoogleDriveResultDictionary : Dictionary<string, string>
    {
        public GoogleDriveResultDictionary(int capacity) : base(capacity)
        {
        }

        public GoogleDriveResultDictionary(IEqualityComparer<string> comparer) : base(comparer)
        {
        }

        public GoogleDriveResultDictionary(IDictionary<string, string> dictionary) : base(dictionary)
        {
        }

        public GoogleDriveResultDictionary(int capacity, IEqualityComparer<string> comparer) : base(capacity, comparer)
        {
        }

        public GoogleDriveResultDictionary(IDictionary<string, string> dictionary, IEqualityComparer<string> comparer) : base(dictionary, comparer)
        {
        }

        protected GoogleDriveResultDictionary() : base() { }

        protected GoogleDriveResultDictionary(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }

    public abstract class GoogleOAuthBase : CloudStorageBase
    {
        protected string AuthParam { get; set; }

        #region response data
        protected class GoogleDriveFileMetadata
        {
            public string kind { get; set; }
            public string id { get; set; }
            public string name { get; set; }
            public string mimeType { get; set; }
            public GoogleDriveFileMetadata() { }
        }

        protected class GoogleFileList
        {
            public GoogleFileList() { files = new Collection<GoogleDriveFileMetadata>(); }

            public string kind { get; set; }
            public Collection<GoogleDriveFileMetadata> files { get; private set; }
        }
        #endregion

        protected GoogleOAuthBase(string szAppKeyKey, string szAppSecretKey, string szOAuth2AuthEndpoint, string szOAuth2TokenEndpoint, string[] scopes = null, string szUpgradeEndpoint = null, string szDisableEndpoint = null) : base(szAppKeyKey, szAppSecretKey, szOAuth2AuthEndpoint, szOAuth2TokenEndpoint, scopes, szUpgradeEndpoint, szDisableEndpoint) { }

        public override IAuthorizationState ConvertToken(HttpRequest Request)
        {
            if (Request == null)
                throw new ArgumentNullException(nameof(Request));

            HttpWebRequest hr = (HttpWebRequest)HttpWebRequest.Create(new Uri(oAuth2TokenEndpoint));
            hr.Method = "POST";
            hr.ContentType = "application/x-www-form-urlencoded";

            string szPostData = String.Format(CultureInfo.InvariantCulture, "code={0}&client_id={1}&client_secret={2}&redirect_uri={3}&grant_type=authorization_code",
                    Request["code"],
                    AppKey,
                    AppSecret,
                    RedirectUri(Request, Request.Path, AuthParam).ToString());

            byte[] rgbData = System.Text.Encoding.UTF8.GetBytes(szPostData);
            hr.ContentLength = rgbData.Length;
            using (Stream s = hr.GetRequestStream())
            {
                s.Write(rgbData, 0, rgbData.Length);
            }

            using (WebResponse response = hr.GetResponse())
            {
                using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                {
                    string result = sr.ReadToEnd();

                    // JSonConvert can't deserialize space-delimited scopes into a hashset, so we need to do that manually.  Uggh.
                    Dictionary<string, string> d = JsonConvert.DeserializeObject<Dictionary<string, string>>(result);

                    AuthorizationState authstate = new AuthorizationState(d.TryGetValue("scope", out string scopes) ? OAuthUtilities.SplitScopes(scopes) : null)
                    {
                        AccessToken = d.TryGetValue("access_token", out string acctok) ? acctok : string.Empty,
                        AccessTokenIssueDateUtc = DateTime.UtcNow
                    };
                    if (d.ContainsKey("expires_in"))
                    {
                        if (int.TryParse(d["expires_in"], NumberStyles.Integer, CultureInfo.InvariantCulture, out int exp))
                            authstate.AccessTokenExpirationUtc = DateTime.UtcNow.AddSeconds(exp);
                    }
                    authstate.RefreshToken = d.TryGetValue("refresh_token", out string reftok) ? reftok : string.Empty;

                    return authstate;
                }
            }
        }
    }

    /// <summary>
    /// Provides utilities for using GoogleDrive from MyFlightbook
    /// </summary>
    public class GoogleDrive : GoogleOAuthBase
    {
        public const string szParamGDriveAuth = "gdOAuth";

        private const string szURLUploadEndpoint = "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart";
        private const string szURLUpdateEndpointTemplate = "https://www.googleapis.com/upload/drive/v3/files/{0}?uploadType=multipart";
        private const string szURLViewFilesEndpointTemplate = "https://www.googleapis.com/drive/v3/files?q={0}&key={1}";

        // The google ID of the root folder where we place files.
        private string RootFolderID { get; set; }

        public GoogleDrive(Profile pf = null)
            : base("GoogleDriveAccessID", "GoogleDriveClientSecret", "https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent", "https://www.googleapis.com/oauth2/v4/token", new string[] { "https://www.googleapis.com/auth/drive.file" })
        {
            AuthParam = szParamGDriveAuth;
            // Issue #1067: put everything under a single root
            // Root path uses backslashes here and is either just the brand name ("MyFlightbook") or it is Brand\year\month.
            RootPath = Branding.CurrentBrand.AppName + (UserUsesFlatHierarchy(pf) ? string.Empty : DateTime.Now.ToString("\\\\yyyy\\\\MM-MMMM", CultureInfo.CurrentCulture));
            RootFolderID = string.Empty;
            CurrentUser = pf;
            AuthState = pf?.GoogleDriveAccessToken;
        }

        protected async Task<string> CreateFolder(string szFolderName, string parentID)
        {
            // Create the metadata.  Name is most important, but we can also specify mimeType for CSV to import into GoogleDocs
            Dictionary<string, object> dictMeta = new Dictionary<string, object>() { { "name", szFolderName }, { "mimeType", "application/vnd.google-apps.folder" } };

            if (!String.IsNullOrEmpty(parentID))
                dictMeta["parents"] = new string[] { parentID };

            // Create the form.  The form itself needs the authtoken header
            using (MultipartContent form = new MultipartContent("related"))
            {
                // Next add the metadata - it is in Json format
                using (StringContent metadata = new StringContent(JsonConvert.SerializeObject(dictMeta)))
                {
                    metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json");
                    form.Add(metadata);

                    return (string)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri(szURLUploadEndpoint), AuthState.AccessToken, form, (response) =>
                    {
                        string szResult = string.Empty;
                        try
                        {
                            szResult = response.Content.ReadAsStringAsync().Result;
                            response.EnsureSuccessStatusCode();
                            if (!String.IsNullOrEmpty(szResult))
                            {
                                GoogleDriveFileMetadata gfm = JsonConvert.DeserializeObject<GoogleDriveFileMetadata>(szResult);
                                if (gfm != null)
                                    return gfm.id;
                            }
                            throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "Unknown result '{0}' returned trying to create folder named '{1}'", szResult, szFolderName));
                        }
                        catch (HttpRequestException ex)
                        {
                            if (response == null)
                                throw new MyFlightbookException("Unknown error in GoogleDrive.CreateFolder", ex);
                            else
                                throw new MyFlightbookException(response.ReasonPhrase + " " + szResult);
                        }
                    });
                }
            }
        }

        #region Finding files and folders on GoogleDrive
        /// <summary>
        /// Returns the URL-based query for Google drive to look for a folder with the specified name
        /// </summary>
        /// <param name="szFolderName">The name of the folder</param>
        /// <returns>The ID of the resulting object (if found)</returns>
        private static string FolderQuery(string szFolderName, string parentID)
        {
            return String.Format(CultureInfo.InvariantCulture, "name%3D%27{0}%27%20and%20trashed%3Dfalse%20and%20mimeType%3D%27application%2Fvnd.google-apps.folder%27", szFolderName) + (String.IsNullOrEmpty(parentID) ? string.Empty : String.Format(CultureInfo.InvariantCulture, "%20and%20%27{0}%27%20in%20parents", parentID));
        }

        /// <summary>
        /// Returns the ID of the leaf of the specified path, creating any folders as needed.
        /// E.g., if you want to put files into "MyFlightbook/2023/08-August", pass ["MyFlightbook", "2023", "08-August"].
        /// If any of those don't exist, they will be created; the id for "08-August" will be returned.
        /// </summary>
        /// <param name="path">An enumerable of folders</param>
        /// <returns>The ID of the leaf node</returns>
        protected async Task<string> GetLeafFolderForPath(IEnumerable<string> path)
        {
            if (path == null)
                return null;

            string lastParentID = null;

            foreach (string folder in path)
            {
                string folderID = await IDForFolder(folder, lastParentID);
                // Create the folder if it wasn't found, under the most recently created parent.
                lastParentID = String.IsNullOrEmpty(folderID) ? await CreateFolder(folder, lastParentID) : folderID;
            }
            return lastParentID;
        }

        /// <summary>
        /// Returns the URL-based query for Google drive to look for a file with the specified name
        /// </summary>
        /// <param name="szFileName">The name of the file</param>
        /// <param name="szParent">The ID of the parent folder</param>
        /// <returns>The ID of the resulting object (if found)</returns>
        protected static string FileQuery(string szFileName, string szParent)
        {
            return String.Format(CultureInfo.InvariantCulture, "name%3D%27{0}%27%20and%20%27{1}%27%20in%20parents%20and%20trashed%3Dfalse", szFileName, szParent);
        }

        /// <summary>
        /// Executes the specified search query, returning the ID of the first object that is found
        /// </summary>
        /// <param name="szQuery">Query (use FolderQuery or FileQuery)</param>
        /// <returns>The ID of the resulting object (if found), else string.empty</returns>
        protected async Task<string> FindIDForQuery(string szQuery)
        {
            // See if the folder exists
            Uri uri = new Uri(String.Format(CultureInfo.InvariantCulture, szURLViewFilesEndpointTemplate, szQuery, AppKey));

            return (string)await SharedHttpClient.GetResponseForAuthenticatedUri(uri, AuthState.AccessToken, HttpMethod.Get, (response) =>
            {
                string szResult = string.Empty;
                try
                {
                    szResult = response.Content.ReadAsStringAsync().Result;
                    response.EnsureSuccessStatusCode();
                    if (!String.IsNullOrEmpty(szResult))
                    {
                        GoogleFileList gfl = JsonConvert.DeserializeObject<GoogleFileList>(szResult);
                        if (gfl != null && gfl.files.Count > 0)
                            return gfl.files[0].id;
                    }
                    return string.Empty;
                }
                catch (HttpRequestException ex)
                {
                    if (response == null)
                        throw new MyFlightbookException("Unknown error in GoogleDrive.GetFolderID", ex);
                    else
                    {
                        Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                        GoogleDriveError gde = (d == null || !d.ContainsKey("error")) ? null : d["error"];
                        if (gde == null || gde.errors.Count == 0)
                            throw new MyFlightbookException(response.ReasonPhrase);
                        else
                            throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "{0} {1}: {2} (Query: {3})", response.ReasonPhrase, gde.errors[0].reason, gde.errors[0].message, szQuery));
                    }
                }
            });
        }

        protected async Task<string> IDForFolder(string szFoldername, string parentID)
        {
            return await FindIDForQuery(FolderQuery(szFoldername, parentID)).ConfigureAwait(false);
        }

        protected async Task<string> IDForFile(string szFileName, string szParentID)
        {
            return await FindIDForQuery(FileQuery(szFileName, szParentID)).ConfigureAwait(false);
        }
        #endregion

        private static void ThrowGDriveError(Exception ex)
        {
            if (ex == null)
                return;
            GDriveError error = JsonConvert.DeserializeObject<GDriveError>(ExtractResponseString(ex.InnerException as WebException));
            if (error == null)
                throw new MyFlightbookException("Unknown error refreshing access token", ex);
            else if (error.error.CompareCurrentCultureIgnoreCase("invalid_grant") == 0)
                throw new UnauthorizedAccessException(Branding.ReBrand(Resources.LocalizedText.GoogleDriveBadAuth), ex);
            else
                throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "Error from Google Drive: {0} {1} {2}", error.error, error.error_description, error.error_link), ex);
        }

        /// <summary>
        /// Puts a file as a stream using the REST API documented at https://developers.google.com/drive/v3/web/manage-uploads#multipart
        /// </summary>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="ms">The stream of the data</param>
        /// <param name="szMimeType">The mime type for the data</param>
        /// <returns>True for success</returns>
        /// <exception cref="MyFlightbookException"></exception>
        /// <exception cref="System.Net.Http.HttpRequestException"></exception>
        public async Task<GoogleDriveResultDictionary> PutFile(string szFileName, Stream ms, string szMimeType)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));

            try
            {
                if (await RefreshAccessToken().ConfigureAwait(false) && CurrentUser != null)
                {
                    CurrentUser.GoogleDriveAccessToken = AuthState;
                    CurrentUser.FCommit();
                }
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException ex)
            {
                ThrowGDriveError(ex);
            }

            bool fIsCSV = szMimeType.CompareCurrentCultureIgnoreCase("text/csv") == 0;

            ms.Seek(0, SeekOrigin.Begin);   // write out the whole stream.  UploadAsync appears to pick up from the current location, which is the end-of-file after writing to a ZIP.

            if (String.IsNullOrEmpty(RootFolderID))
                RootFolderID = await GetLeafFolderForPath(RootPath.Split(new char[] { '\\' }, StringSplitOptions.RemoveEmptyEntries));

            // CSV loses its extension when uploaded because we map it to a google spreadsheet.  So if it's CSV AND we are patching an existing file, drop the extension so that we ov
            // update the existing file if it is present.  If CSV, strip the extension
            string szFileNameToCheck = fIsCSV ? Path.GetFileNameWithoutExtension(szFileName) : szFileName;
            string idExisting = null;
            if (!String.IsNullOrEmpty(RootFolderID))
                idExisting = await IDForFile(szFileNameToCheck, RootFolderID).ConfigureAwait(false);

            // If we got a hit, use that filename for the udpate
            if (!String.IsNullOrEmpty(idExisting))
                szFileName = szFileNameToCheck;

            // Create the metadata.  Name is most important, but we can also specify mimeType for CSV to import into GoogleDocs
            Dictionary<string, object> dictMeta = new Dictionary<string, object>() { { "name", szFileName } };
            if (fIsCSV)
                dictMeta["mimeType"] = "application/vnd.google-apps.spreadsheet";   // get it to show up in google drive sheets.
            if (String.IsNullOrEmpty(idExisting) && !String.IsNullOrEmpty(RootFolderID))
                dictMeta["parents"] = new List<string>() { RootFolderID };

            return await SendForm(AuthState.AccessToken, ms, dictMeta, szMimeType, idExisting).ConfigureAwait(false);
        }

        private static async Task<GoogleDriveResultDictionary> SendForm(string szToken, Stream ms, Dictionary<string, object> dictMeta, string szMimeType, string idExisting)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));

            int cRetry = 0;     // # of attempts that have been made so far
            const int MaxRetry = 3; // maximum number of attempts

            GoogleDriveResultDictionary result = null;

            // Write the memory stream to a file so that we can do exponential backoff, since we'll end up closing the stream.

            while (cRetry++ < MaxRetry)
            {
                // Create the form.  The form itself needs the authtoken header
                using (MultipartContent form = new MultipartContent("related"))
                {
                    // Next add the metadata - it is in Json format
                    string szJSonMeta = JsonConvert.SerializeObject(dictMeta);
                    using (StringContent metadata = new StringContent(szJSonMeta, System.Text.Encoding.UTF8))
                    {
                        metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json") { CharSet = "UTF-8" };
                        form.Add(metadata);

                        using (FileStream fs = new FileStream(Path.GetTempFileName(), FileMode.Open, FileAccess.ReadWrite, FileShare.None, Int16.MaxValue, FileOptions.DeleteOnClose))
                        {
                            // copy from the filestream to a new temp file, so that we can do exponential backoff if needed.
                            ms.Seek(0, SeekOrigin.Begin);   // write out the whole file!
                            ms.CopyTo(fs);
                            fs.Seek(0, SeekOrigin.Begin);

                            // Finally, add the body, with its appropriate mime type.
                            using (StreamContent body = new StreamContent(fs))
                            {
                                body.Headers.ContentType = new MediaTypeHeaderValue(szMimeType);
                                form.Add(body);

                                bool fExisting = !String.IsNullOrEmpty(idExisting);
                                Uri Target = fExisting ? new Uri(String.Format(CultureInfo.InvariantCulture, szURLUpdateEndpointTemplate, idExisting)) : new Uri(szURLUploadEndpoint);
                                HttpMethod method = fExisting ? new HttpMethod("PATCH") : HttpMethod.Post;

                                result = (GoogleDriveResultDictionary)await SharedHttpClient.GetResponseForAuthenticatedUri(Target, szToken, method, form, (response) =>
                                {
                                    string szResult = string.Empty;

                                    try
                                    {
                                        szResult = response.Content.ReadAsStringAsync().Result;
                                        // DEBUG: szResult = "{\"error\": {\"errors\": [{\"domain\": \"usageLimits\",\"reason\": \"userRateLimitExceeded\",\"message\": \"User rate limit exceeded.\"}],\"code\": 403,\"message\": \"User rate limit exceeded.\"}}";
                                        // DEBUG: throw new HttpRequestException(szResult);
                                        response.EnsureSuccessStatusCode();
                                        return String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<GoogleDriveResultDictionary>(szResult);
                                    }
                                    catch (HttpRequestException ex)
                                    {
                                        if (response == null)
                                            throw new MyFlightbookException("Unknown error in GoogleDrive.PutFile", ex);

                                        Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                                        GoogleDriveError gde = (d == null || !d.ContainsKey("error")) ? null : d["error"];

                                        bool fHasReason = gde != null && gde.errors != null && gde.errors.Count > 0 && gde.errors[0].reason != null;
                                        if (fHasReason)
                                        {
                                            if (gde.code == 403)
                                            {
                                                if (gde.errors[0].reason.CompareCurrentCultureIgnoreCase("storageQuotaExceeded") == 0)
                                                    throw new MyFlightbookException(Resources.LocalizedText.GoogleDriveOutOfSpace);
                                                else if (gde.errors[0].reason.CompareCurrentCultureIgnoreCase("userRateLimitExceeded") == 0)
                                                {
                                                    if (cRetry < MaxRetry)
                                                    {
                                                        // exponential backoff.
                                                        System.Threading.Thread.Sleep(1000 * (1 << (cRetry - 1)));
                                                        // fall through, we'll try again.
                                                        return null;
                                                    }
                                                    else // too many attempts - just report that as an error.
                                                        throw new MyFlightbookException(gde.message);
                                                }
                                            }

                                            // We have a GoogleDrive error, but it was not a 403 or it was not quota/ratelimit.
                                            throw new MyFlightbookException(response.ReasonPhrase + " " + gde.errors[0].reason + ": " + gde.errors[0].message ?? string.Empty);
                                        }
                                        else
                                            throw new MyFlightbookException(response.ReasonPhrase + " " + (szResult ?? string.Empty));
                                    }
                                });
                            }
                        }
                    }
                }

                if (result != null || cRetry >= MaxRetry)
                    break;
            }

            return result;
        }
    }
    #endregion

    #region OneDrive
    public enum OneDriveErrorCodeMFB
    {
        Unknown = -1,
        AccessDenied = 0,
        ActivityLimitReached = 1,
        AuthenticationCancelled = 2,
        AuthenticationFailure = 3,
        GeneralException = 4,
        InvalidRange = 5,
        InvalidRequest = 6,
        ItemNotFound = 7,
        MalwareDetected = 8,
        MyFilesCapabilityNotFound = 9,
        NameAlreadyExists = 10,
        NotAllowed = 11,
        NotSupported = 12,
        ResourceModified = 13,
        ResyncRequired = 14,
        ServiceNotAvailable = 15,
        Timeout = 16,
        TooManyRedirects = 17,
        QuotaLimitReached = 18,
        Unauthenticated = 19,
        UserDoesNotHaveMyFilesService = 20
    }

    public class OneDriveError
    {
        OneDriveErrorCodeMFB ErrorCode { get; set; }

        public string Message { get; set; }

        public OneDriveError(OneDriveErrorCodeMFB errCode)
        {
            ErrorCode = errCode;
            Message = MessageForCode(errCode, string.Empty);
        }

        protected static string MessageForCode(OneDriveErrorCodeMFB errCode, string szDefault)
        {
            switch (errCode)
            {
                case OneDriveErrorCodeMFB.AccessDenied:
                case OneDriveErrorCodeMFB.AuthenticationCancelled:
                case OneDriveErrorCodeMFB.AuthenticationFailure:
                case OneDriveErrorCodeMFB.Unauthenticated:
                    return Branding.ReBrand(Resources.LocalizedText.OneDriveBadAuth);
                case OneDriveErrorCodeMFB.QuotaLimitReached:
                    return Resources.LocalizedText.OneDriveErrorOutOfSpace;
                case OneDriveErrorCodeMFB.Timeout:
                case OneDriveErrorCodeMFB.ServiceNotAvailable:
                case OneDriveErrorCodeMFB.TooManyRedirects:
                    return Resources.LocalizedText.OneDriveCantReachService;
                default:
                    return String.Format(CultureInfo.CurrentCulture, "{0} {1}", errCode.ToString(), String.IsNullOrEmpty(szDefault) ? string.Empty : String.Format(CultureInfo.CurrentCulture, "({0})", szDefault));
            }
        }

        public OneDriveError(string szJSon) : base()
        {
            Message = string.Empty;
            ErrorCode = OneDriveErrorCodeMFB.Unknown;

            if (String.IsNullOrEmpty(szJSon))
                return;

            try
            {
                dynamic result = JObject.Parse(szJSon);
                if (Enum.TryParse((string) result.error.code, true, out OneDriveErrorCodeMFB errCode))
                {
                    ErrorCode = errCode;
                    Message = MessageForCode(ErrorCode, (string) result.error.message);
                }
                else
                    Message = String.Format(CultureInfo.CurrentCulture, "{0} (OneDrive returned: {1})", result.error.message, szJSon);
            }
            catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException)
            {
                Message = String.Format(CultureInfo.InvariantCulture, "Error in OneDrive response: {0}", szJSon);
            }
            catch (JsonReaderException)
            {
                Message = String.Format(CultureInfo.InvariantCulture, "Invalid response from OneDrive: {0}", szJSon);
            }
        }

        public override string ToString()
        {
            return String.Format(CultureInfo.CurrentCulture, "{0}: {1}", ErrorCode, Message);
        }
    }

    [Serializable]
    public class OneDriveMFBException : Exception
    {
        public OneDriveError Error { get; set; }
        public OneDriveMFBException(string message) : base(message)
        {
            Error = null;
        }

        public OneDriveMFBException(string message, Exception innerException) : base(message, innerException)
        {
            Error = null;
        }

        public OneDriveMFBException(OneDriveError err) : base(err == null ? string.Empty : err.Message)
        {
            Error = err;
        }
            
        public OneDriveMFBException(OneDriveError err, Exception innerException) : base(err == null ? string.Empty : err.Message, innerException)
        {
            Error = err;
        }

        public OneDriveMFBException()
        {
            Error = null;
        }

        protected OneDriveMFBException(SerializationInfo serializationInfo, StreamingContext streamingContext): base(serializationInfo, streamingContext)
        {
            Error = null;
        }

        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);

            info.AddValue("Error", Error);
        }
    }

    internal class OneDriveSession
    {
        [JsonProperty("uploadUrl")]
        public string UploadEndpoint { get; set; }

        public Uri UploadUri
        {
            get { return new Uri(UploadEndpoint ?? string.Empty); }
        }

        [JsonProperty("expirationDateTime")]
        public DateTime Expiration { get; set; }

        [JsonProperty("nextExpectedRanges")]
        public Collection<string> ExpectedRanges { get; set; }

        public OneDriveSession()
        {
            UploadEndpoint = string.Empty;
            ExpectedRanges = new Collection<string>();
            Expiration = DateTime.MinValue;
        }
    }

    /// <summary>
    /// Provides utilities for using OneDrive from MyFlightbook
    /// 
    /// Useful resources:
    ///   - oAuth flow and endpoints: https://dev.onedrive.com/auth/msa_oauth.htm
    ///   - Rest API for uploading: https://docs.microsoft.com/en-us/onedrive/developer/rest-api/concepts/upload?view=odsp-graph-online
    /// </summary>
    public class OneDrive : CloudStorageBase
    {
        public const string TokenSessionKey = "sessionkeyforonedrive";
        public const string szParam1DriveAuth = "1dOAuth";
        private const int MinFileSizeResumable = 4000000;   // files that are 4MB+ require a resumable upload.

        public OneDrive(Profile pf = null) 
            : base("OneDriveAccessID", "OneDriveClientSecret", "https://login.live.com/oauth20_authorize.srf", "https://login.live.com/oauth20_token.srf", new string[] { "onedrive.appfolder", "wl.basic", "onedrive.readwrite", "wl.offline_access" })
        {
            RootPath = UserUsesFlatHierarchy(pf) ? Branding.CurrentBrand.AppName + "/" : String.Format(CultureInfo.InvariantCulture, "{0}/{1}/{2}/", Branding.CurrentBrand.AppName, DateTime.Now.ToString("yyyy", CultureInfo.CurrentCulture), DateTime.Now.ToString("MM-MMMM", CultureInfo.CurrentCulture));
            CurrentUser = pf;
            AuthState = pf?.OneDriveAccessToken;
        }

        protected static void HandleInvalidAuth(Exception ex)
        {
            if (ex == null)
                throw new ArgumentNullException(nameof(ex));

            string szResponse = ExtractResponseString(ex.InnerException as WebException);
            try
            {
                dynamic error = JsonConvert.DeserializeObject(szResponse);
                if (error == null)
                    throw new MyFlightbookException("Unknown error refreshing access token", ex);
                else if (error.error != null && String.Compare(error.error.ToString(), "invalid_grant", StringComparison.InvariantCulture) == 0)
                {
                    OneDriveMFBException ode = new OneDriveMFBException(new OneDriveError(OneDriveErrorCodeMFB.AuthenticationFailure), ex);
                    throw new UnauthorizedAccessException(ode.Message, ode);
                }
                else
                    throw new MyFlightbookException(Branding.ReBrand(Resources.LocalizedText.OneDriveBadAuth));
            }
            catch (JsonReaderException ex2)
            {
                throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "Unable to deserialize response '{0}': {1}", szResponse, ex2.Message), ex);
            }
        }

        private static UriBuilder BuilderForPath(string szPath)
        {
            return new UriBuilder("https://api.onedrive.com")
            {
                Query = string.Empty,
                Path = szPath
            };
        }

        internal async Task<OneDriveSession> GetResumableSession(string szFilename)
        {
            string szResult = string.Empty;

            Dictionary<string, string> d = new Dictionary<string, string>()
                    {
                        { "@microsoft.graph.conflictBehavior", "replace" },
                        { "name", szFilename }
                    };
            Dictionary<string, object> d2 = new Dictionary<string, object>() { { "item", d } };
            using (StringContent sc = new StringContent(JsonConvert.SerializeObject(d2), System.Text.Encoding.UTF8, "application/json"))
            {
                UriBuilder builder = BuilderForPath(String.Format(CultureInfo.InvariantCulture, "v1.0/drive/root:/{0}{1}:/createUploadSession", RootPath, szFilename));

                return (OneDriveSession)await SharedHttpClient.GetResponseForAuthenticatedUri(builder.Uri, AuthState.AccessToken, sc, (response) =>
                {
                    try
                    {
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        // Deserialize (below) should never return null because EnsureSuccessStatusCode should throw an exception if there's an issue, but this suppresses a warning about uninstantiated OneDriveSession
                        return JsonConvert.DeserializeObject<OneDriveSession>(szResult) ?? new OneDriveSession();
                    }
                    catch (HttpRequestException ex)
                    {
                        if (response == null)
                            throw new MyFlightbookException("Unknown error in OneDrive.PutFileDirect", ex);
                        else
                            throw new OneDriveMFBException(new OneDriveError(szResult));
                    }
                });
            }
        }

        public async Task<bool> PutFileDirect(string szFilename, Stream ms, string szMimeType)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));
            ms.Seek(0, SeekOrigin.Begin);
            try
            {
                if (await RefreshAccessToken().ConfigureAwait(false) && CurrentUser != null)
                {
                    CurrentUser.OneDriveAccessToken = AuthState;
                    CurrentUser.FCommit();
                }
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException ex)
            {
                HandleInvalidAuth(ex);
            }

            string szResult = string.Empty;

            // See if we need to do a resumable session
            OneDriveSession session = (ms.Length > MinFileSizeResumable) ? await GetResumableSession(szFilename).ConfigureAwait(false) : null;

            using (StreamContent body = new StreamContent(ms))
            {
                body.Headers.ContentType = new MediaTypeHeaderValue(szMimeType);
                body.Headers.ContentDisposition = (new ContentDispositionHeaderValue("form-data") { Name = szFilename, FileName = szFilename });

                UriBuilder builder = BuilderForPath(String.Format(CultureInfo.InvariantCulture, "v1.0/drive/root:/{0}{1}:/content", RootPath, szFilename));
                if (session != null)
                {
                    body.Headers.ContentLength = ms.Length;
                    body.Headers.ContentRange = new ContentRangeHeaderValue(0, ms.Length - 1, ms.Length) { Unit = "bytes" };
                }

                return (bool)await SharedHttpClient.GetResponseForAuthenticatedUri(session == null ? builder.Uri : session.UploadUri, AuthState.AccessToken, HttpMethod.Put, body, (response) =>
                {
                    try
                    {
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        return !String.IsNullOrEmpty(szResult);
                    }
                    catch (HttpRequestException ex)
                    {
                        if (response == null)
                            throw new MyFlightbookException("Unknown error in OneDrive.PutFileDirect", ex);
                        else
                            throw new OneDriveMFBException(new OneDriveError(szResult));
                    }
                });
            }
        }

        public async Task<bool> PutFileDirect(string szFileName, byte[] rgData, string szMimeType)
        {
            using (MemoryStream ms = new MemoryStream(rgData))
            {
                return await PutFileDirect(szFileName, ms, szMimeType).ConfigureAwait(false);
            }
        }
    }
    #endregion

    #region Dropbox
    /// <summary>
    /// Provides utilities for using Dropbox from MyFlightbook
    /// </summary>
    public class MFBDropbox: CloudStorageBase
    {
        public enum TokenStatus { None, oAuth1, oAuth2 }
        public const string szParamDropboxAuth = "dbOAuth";

        public MFBDropbox(Profile pf = null)
            : base("DropboxAccessID", "DropboxClientSecret", "https://www.dropbox.com/oauth2/authorize?token_access_type=offline", "https://api.dropboxapi.com/oauth2/token", 
                  new string[] { "files.content.write", "files.content.read", "files.metadata.write", "files.metadata.read" }, "https://api.dropboxapi.com/2/auth/token/from_oauth1", "https://api.dropboxapi.com/2/auth/token/revoke")
        {
            CurrentUser = pf;
            RootPath = UserUsesFlatHierarchy(pf) ? "/" : String.Format(CultureInfo.InvariantCulture, "/{0}/{1}/", DateTime.Now.ToString("yyyy", CultureInfo.CurrentCulture), DateTime.Now.ToString("MM-MMMM", CultureInfo.CurrentCulture));
        }

        /// <summary>
        /// Determines the type of dropbox oAuth token we have.  Optionally upgrades to an oAuth 2.0 credential and/or disables the existing one.
        /// MODIFIES THE IN MEMORY USER PROFILE to use an upgraded credential
        /// </summary>
        /// <param name="pf">The user profile</param>
        /// <param name="fCommit">True to update the database with the oAuth 2.0 credential</param>
        /// <returns>The state of the dropbox access token PRIOR to upgrade.</returns>
        async public Task<TokenStatus> ValidateDropboxToken()
        {
            TokenStatus result = TokenStatus.None;

            if (CurrentUser == null || String.IsNullOrEmpty(CurrentUser.DropboxAccessToken))
                return result;

            try
            {
                string dbAppKey = AppKey;
                string dbSecret = AppSecret;

                byte[] rgbOAuth1Token = Convert.FromBase64String(CurrentUser.DropboxAccessToken);
                string xmlOAuth1Token = System.Text.Encoding.Default.GetString(rgbOAuth1Token);
                // if we get here, it is probably an oAuth1 token

                if (xmlOAuth1Token.Trim().StartsWith("<", StringComparison.OrdinalIgnoreCase))
                {
                    string szRawToken = null;
                    string szRawSecret = null;

                    using (MemoryStream stream = new MemoryStream(rgbOAuth1Token))
                    {
                        DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<string, string>));
                        Object o = serializer.ReadObject(stream);
                        if (o.GetType().Equals(typeof(Dictionary<string, string>)))
                        {
                            Dictionary<string, string> d = (Dictionary<string, string>)o;
                            szRawToken = d["TokenDropBoxUsername"];
                            szRawSecret = d["TokenDropBoxPassword"];
                        }
                    }


                    try
                    {
                        using (DropboxAppClient client = new DropboxAppClient(dbAppKey, dbSecret))
                        {
                            var tokenFromOAuth1Result = await client.Auth.TokenFromOauth1Async(szRawToken, szRawSecret).ConfigureAwait(false);
                            CurrentUser.DropboxAccessToken = tokenFromOAuth1Result.Oauth2Token;
                        }

                        CurrentUser.FCommit();

                        result = TokenStatus.oAuth1;
                    }
                    catch (Exception ex) when (ex is WebException)
                    {
                    }
                }
                else
                    result = TokenStatus.oAuth2;
            }
            catch (Exception ex) when (ex is FormatException)
            {
                // It should be v2!
                result = TokenStatus.oAuth2;
            }
            return result;
        }

        /// <summary>
        /// Puts a file as an array of bytes
        /// </summary>
        /// <param name="szDropboxAccessToken">The oAuth 2.0 access token</param>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="rgData">The array of bytes</param>
        /// <returns>FileMetadata with the result</returns>
        public async Task<Dropbox.Api.Files.FileMetadata> PutFile(string szFileName, byte[] rgData)
        {
            using (MemoryStream ms = new MemoryStream(rgData))
            {
                return await PutFile(szFileName, ms).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Puts a file as a stream
        /// </summary>
        /// <param name="szDropboxAccessToken">The oAuth 2.0 access token</param>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="ms">The stream of the data</param>
        /// <returns>FileMetadata with the result</returns>
        public async Task<Dropbox.Api.Files.FileMetadata> PutFile(string szFileName, Stream ms)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));
            if (CurrentUser == null)
                throw new MyFlightbookValidationException("Can't put file without a user profile object");
            if (String.IsNullOrWhiteSpace(CurrentUser.DropboxAccessToken))
                throw new MyFlightbookValidationException(String.Format(CultureInfo.CurrentCulture, "User {0} doesn't have a dropbox access token", CurrentUser.UserName));

            ms.Seek(0, SeekOrigin.Begin);   // write out the whole stream.  UploadAsync appears to pick up from the current location, which is the end-of-file after writing to a ZIP.

            // The token as provided might be a legacy long-lived one, which we use directly, or a newer JSON authstate, which includes a refresh token.  Start by assuming legacy.
            string szToken = CurrentUser.DropboxAccessToken;

            // if JSonConvert succeeds, then we can read the full authstate, including refreshtoken and expiration date.
            if (szToken.StartsWith("{", StringComparison.OrdinalIgnoreCase))
            {
                try
                {
                    IAuthorizationState auth = JsonConvert.DeserializeObject<AuthorizationState>(szToken);
                    // if here, it deserialized correctly so we can use it.

                    AuthState = auth;

                    await RefreshAccessToken().ConfigureAwait(false);
                    szToken = AuthState.AccessToken;
                }
                catch (JsonException) { }
                catch (DotNetOpenAuth.Messaging.ProtocolException ex) { throw new UnauthorizedAccessException(ex.Message, ex); }
            }

            using (DropboxClient dbx = new DropboxClient(szToken))
            {
                Dropbox.Api.Files.FileMetadata updated = await dbx.Files.UploadAsync(RootPath + szFileName, Dropbox.Api.Files.WriteMode.Overwrite.Instance, body: ms).ConfigureAwait(false);
                return updated;
            }
        }
    }
    #endregion

    #region Google Photo
    [Serializable]
    public class GoogleImageDate
    {
        public int year { get; set; }
        public int month { get; set; }
        public int day { get; set; }

        public GoogleImageDate() { }

        public GoogleImageDate(DateTime dt) : this()
        {
            year = dt.Year;
            month = dt.Month;
            day = dt.Day;
        }
    }

    [Serializable]
    public class GoogleDateFilter
    {
        public IEnumerable<GoogleImageDate> dates { get; set; }

        public GoogleDateFilter()
        {
            dates = new List<GoogleImageDate>();
        }

        public GoogleDateFilter(DateTime dt)
        {
            dates = new GoogleImageDate[] { new GoogleImageDate(dt) };
        }
    }

    [Serializable]
    public class GoogleMediaTypeFilter
    {
        public IEnumerable<string> mediaTypes { get; set; } = new string[] { GoogleMediaType.ALL_MEDIA.ToString() };
    }

    public enum GoogleMediaType { ALL_MEDIA, VIDEO, PHOTO };

    [Serializable]
    public class GoogleImageFilter
    {
        public GoogleDateFilter dateFilter { get; set; }

        public GoogleMediaTypeFilter mediaTypeFilter { get; set; }
    }

    [Serializable]
    public class GoogleImageRequest
    {
        public int pageSize { get; set; }
        public string pageToken { get; set; }
        public GoogleImageFilter filters { get; set; }


        public GoogleImageRequest()
        {
            pageSize = 10;
            pageToken = string.Empty;
            filters = null;
        }
    }

    [Serializable]
    public class GoogleMediaItem
    {
        public string id { get; set; }
        public string description { get; set; }

#pragma warning disable CA1056 // URI-like properties should not be strings
        public string productUrl { get; set; }
        public string baseUrl { get; set; }
#pragma warning restore CA1056 // URI-like properties should not be strings

        public string mimeType { get; set; }
        public string filename { get; set; }

        public GoogleMediaMetaData mediaMetadata { get; set; }
    }

    [Serializable]
    public class GoogleMediaMetaData
    {
        public string creationTime { get; set; }

        public string width { get; set; }

        public string height { get; set; }

        public DateTime? CreationTime { get { return String.IsNullOrEmpty(creationTime) ? null : new DateTime?(creationTime.ParseUTCDateTime()); } }

        public int Width { get { return String.IsNullOrEmpty(width) ? 0 : int.Parse(width, CultureInfo.InvariantCulture); } }

        public int Height { get { return String.IsNullOrEmpty(height) ? 0 : int.Parse(height, CultureInfo.InvariantCulture); } }
    }

    [Serializable]
    public class GoogleMediaResponse
    {
        public IEnumerable<GoogleMediaItem> mediaItems { get; set; } = Array.Empty<GoogleMediaItem>();
        public string nextPageToken { get; set; }

        public GoogleMediaResponse AddResponse(GoogleMediaResponse gmr)
        {
            if (gmr == null)
                return this;

            nextPageToken = gmr.nextPageToken;

            List<GoogleMediaItem> lst = (mediaItems == null) ? new List<GoogleMediaItem>() : new List<GoogleMediaItem>(mediaItems);
            if (gmr.mediaItems != null)
                lst.AddRange(gmr.mediaItems);
            mediaItems = lst;
            return this;
        }

        /// <summary>
        /// Returns the media item matching the specified reference and removes it from the list.
        /// </summary>
        /// <param name="href"></param>
        /// <returns></returns>
        protected GoogleMediaItem RemoveByHRef(string href)
        {
            if (String.IsNullOrEmpty(href) || mediaItems == null || !mediaItems.Any())
                return null;

            List<GoogleMediaItem> lst = new List<GoogleMediaItem>(mediaItems);

            GoogleMediaItem item = lst.Find(mi => mi.productUrl.CompareOrdinal(href) == 0);
            if (item != null)
            {
                lst.Remove(item);
                mediaItems = lst;
            }
            return item;
        }

        public MFBPostedFile ImportImage(string href)
        {
            GoogleMediaItem item = RemoveByHRef(href);
            if (item == null)
                return null;

            Uri uri = new Uri(String.Format(CultureInfo.InvariantCulture, "{0}={1}", item.baseUrl, (item.mimeType.StartsWith("image/", StringComparison.CurrentCultureIgnoreCase)) ? "d" : "dv"));

            return MFBPostedFile.PostedFileFromURL(uri, item.filename, item.mimeType);
        }
    }

    public class GooglePhoto : GoogleOAuthBase
    {
        public const string szParamGPhotoAuth = "gPhotoOAuth";
        public const string PrefKeyAuthToken = "googlePhotoAuthToken";

        public GooglePhoto(Profile pf = null) : base("GoogleDriveAccessID", "GoogleDriveClientSecret", "https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent", "https://www.googleapis.com/oauth2/v4/token", new string[] { "https://www.googleapis.com/auth/photoslibrary.readonly" })
        {
            AuthParam = szParamGPhotoAuth;
            CurrentUser = pf;
            if (pf != null)
            {
                string szAuthJSon = pf?.GetPreferenceForKey<string>(PrefKeyAuthToken, null);
                if (!String.IsNullOrWhiteSpace(szAuthJSon))
                    AuthState = JsonConvert.DeserializeObject<AuthorizationState>(szAuthJSon);
            }
        }

        public GooglePhoto(Profile pf, IAuthorizationState authstate) : this(pf)
        {
            AuthState = authstate;
        }

        public async Task<string> GetImagesForDate(DateTime dt, bool fIncludeVideos, string nextPageToken)
        {
            string szResult = string.Empty;
            try
            {
                if (await RefreshAccessToken().ConfigureAwait(false) && CurrentUser != null)
                    CurrentUser.SetPreferenceForKey(GooglePhoto.PrefKeyAuthToken, JsonConvert.SerializeObject(AuthState));
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException)
            {
                return string.Empty;
            }

            GoogleImageRequest googleImageRequest = new GoogleImageRequest() { filters = new GoogleImageFilter() { dateFilter = new GoogleDateFilter(dt) }, pageToken = nextPageToken };
            if (!fIncludeVideos)
                googleImageRequest.filters.mediaTypeFilter = new GoogleMediaTypeFilter() { mediaTypes = new string[] { GoogleMediaType.PHOTO.ToString() } };

            string imgReqJSON = JsonConvert.SerializeObject(googleImageRequest);

            using (StringContent sc = new StringContent(imgReqJSON, System.Text.Encoding.UTF8))
            {
                sc.Headers.ContentType = new MediaTypeHeaderValue("application/json") { CharSet = "UTF-8" };

                Dictionary<string, string> dHeaders = new Dictionary<string, string>()
                    {
                        {"Accept", "application/json" },
                        { "referer", String.Format(CultureInfo.InvariantCulture, "https://{0}", Branding.CurrentBrand.HostName) }
                    };

                return (string)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri(String.Format(CultureInfo.InvariantCulture, "https://photoslibrary.googleapis.com/v1/mediaItems:search?key={0}", MyFlightbook.SocialMedia.GooglePlusConstants.MapsKey)),
                    AuthState.AccessToken, HttpMethod.Post, sc, (response) =>
                    {
                        try
                        {
                            szResult = response.Content.ReadAsStringAsync().Result;
                            response.EnsureSuccessStatusCode();
                            return szResult;
                        }
                        catch (HttpRequestException ex)
                        {
                            if (response == null)
                                throw new MyFlightbookException("Unknown error in GetImagesForDate", ex);

                            Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                            GoogleDriveError gde = (d == null || !d.ContainsKey("error")) ? null : d["error"];

                            throw new MyFlightbookException(response.ReasonPhrase + " " + (szResult ?? string.Empty));
                        }
                    }, dHeaders);
            }
        }

        public async static Task<GoogleMediaResponse> AppendImagesForDate(Profile pf, DateTime dt, bool fCanDoVideo, GoogleMediaResponse priorResponse)
        {
            string szResult = await new GooglePhoto(pf).GetImagesForDate(dt, fCanDoVideo, priorResponse?.nextPageToken).ConfigureAwait(false);
            GoogleMediaResponse result = JsonConvert.DeserializeObject<GoogleMediaResponse>(szResult);

            return (priorResponse == null) ? result : priorResponse.AddResponse(result);
        }
    }
    #endregion
}