using DotNetOpenAuth.OAuth2;
using Dropbox.Api;
using MyFlightbook.Image;
using MyFlightbook.OAuth;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Threading.Tasks;
using System.Web;

/******************************************************
 * 
 * Copyright (c) 2016-2026 MyFlightbook LLC
 * Contact myflightbook-at-gmail.com for more information
 *
*******************************************************/

namespace MyFlightbook.CloudStorage
{
    /// <summary>
    /// Specifies the default cloud storage to use for a given user if they've authorized more than one.
    /// </summary>
    public enum StorageID { None, Dropbox, GoogleDrive, OneDrive, Box }

    /// <summary>
    /// Base class for cloud storage
    /// </summary>
    public abstract class CloudStorageBase : OAuthClientBase
    {
        /// <summary>
        /// Creates a cloud storage provider using parameters for oAuth authentication and token retrieval
        /// </summary>
        /// <param name="szAppKeyKey">The LocalConfig key for the oAuth2 appeky</param>
        /// <param name="szAppSecretKey">The LocalConfig key for the oAuth2 secret</param>
        /// <param name="szOAuth2AuthEndpoint">The oAuth2 authorization endpoint URL</param>
        /// <param name="szOAuth2TokenEndpoint">The oAuth2 token endpoint URL</param>
        /// <param name="scopes">Array of scopes for oAuth</param>
        protected CloudStorageBase(string szAppKeyKey, string szAppSecretKey, string szOAuth2AuthEndpoint, string szOAuth2TokenEndpoint, string[] scopes = null, string szUpgradeEndpoint = null, string szDisableEndpoint = null) : 
            base(szAppKeyKey, szAppSecretKey, szOAuth2AuthEndpoint, szOAuth2TokenEndpoint, scopes, szUpgradeEndpoint, szDisableEndpoint)
        {
        }

        public static string CloudStorageName(StorageID sid)
        {
            switch (sid)
            {
                case StorageID.Dropbox:
                    return Resources.LocalizedText.CloudStorageDropbox;
                case StorageID.GoogleDrive:
                    return Resources.LocalizedText.CloudStorageGDrive;
                case StorageID.OneDrive:
                    return Resources.LocalizedText.CloudStorageOneDrive;
                case StorageID.Box:
                    return Resources.LocalizedText.CloudStorageBox;
                case StorageID.None:
                default:
                    return string.Empty;
            }
        }

        /// <summary>
        /// The current user
        /// </summary>
        protected Profile CurrentUser { get; set; }

        public static bool UserUsesFlatHierarchy(Profile pf)
        {
            return pf != null && pf.GetPreferenceForKey(MFBConstants.keyPrefFlatHierarchy, false);
        }

        public static void SetUsesFlatHierarchy(Profile pf, bool value)
        {
            pf?.SetPreferenceForKey(MFBConstants.keyPrefFlatHierarchy, value, value == false);
        }
    }

    #region Google Drive
    #region Google Drive Errors
#pragma warning disable CA1507 // Use nameof to express symbol names
    /*
     * Generated by Xamasoft JSON Class Generator http://www.xamasoft.com/json-class-generator
     */
    [Serializable]
    public class GoogleDriveInternalError
    {

        [JsonProperty("domain")]
        public string domain { get; set; }

        [JsonProperty("reason")]
        public string reason { get; set; }

        [JsonProperty("message")]
        public string message { get; set; }
    }

    [Serializable]
    public class GoogleDriveError
    {

        [JsonProperty("errors")]
        public Collection<GoogleDriveInternalError> errors { get; private set; }

        [JsonProperty("code")]
        public int code { get; set; }

        [JsonProperty("message")]
        public string message { get; set; }

        public GoogleDriveError()
        {
            errors = new Collection<GoogleDriveInternalError>();
        }
    }
#pragma warning restore CA1507 // Use nameof to express symbol names
    #endregion

    [Serializable]
    public class GoogleDriveResultDictionary : Dictionary<string, string>
    {
        public GoogleDriveResultDictionary(int capacity) : base(capacity)
        {
        }

        public GoogleDriveResultDictionary(IEqualityComparer<string> comparer) : base(comparer)
        {
        }

        public GoogleDriveResultDictionary(IDictionary<string, string> dictionary) : base(dictionary)
        {
        }

        public GoogleDriveResultDictionary(int capacity, IEqualityComparer<string> comparer) : base(capacity, comparer)
        {
        }

        public GoogleDriveResultDictionary(IDictionary<string, string> dictionary, IEqualityComparer<string> comparer) : base(dictionary, comparer)
        {
        }

        protected GoogleDriveResultDictionary() : base() { }

        protected GoogleDriveResultDictionary(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }

    public abstract class GoogleOAuthBase : CloudStorageBase
    {
        protected string AuthParam { get; set; }

        #region response data
        protected class GoogleDriveFileMetadata
        {
            public string kind { get; set; }
            public string id { get; set; }
            public string name { get; set; }
            public string mimeType { get; set; }
            public GoogleDriveFileMetadata() { }
        }

        protected class GoogleFileList
        {
            public GoogleFileList() { files = new Collection<GoogleDriveFileMetadata>(); }

            public string kind { get; set; }
            public Collection<GoogleDriveFileMetadata> files { get; private set; }
        }
        #endregion

        protected GoogleOAuthBase(string szAppKeyKey, string szAppSecretKey, string szOAuth2AuthEndpoint, string szOAuth2TokenEndpoint, string[] scopes = null, string szUpgradeEndpoint = null, string szDisableEndpoint = null) : base(szAppKeyKey, szAppSecretKey, szOAuth2AuthEndpoint, szOAuth2TokenEndpoint, scopes, szUpgradeEndpoint, szDisableEndpoint) { }

        public override IAuthorizationState ConvertToken(HttpRequestBase Request)
        {
            if (Request == null)
                throw new ArgumentNullException(nameof(Request));

            // TODO: We should make this code async and replace it with a call to the async convert token code.
            HttpWebRequest hr = (HttpWebRequest)HttpWebRequest.Create(new Uri(oAuth2TokenEndpoint));
            hr.Method = "POST";
            hr.ContentType = "application/x-www-form-urlencoded";

            string szPostData = String.Format(CultureInfo.InvariantCulture, "code={0}&client_id={1}&client_secret={2}&redirect_uri={3}&grant_type=authorization_code",
                    Request["code"],
                    AppKey,
                    AppSecret,
                    RedirectUri(Request, Request.Path, AuthParam).ToString());

            byte[] rgbData = System.Text.Encoding.UTF8.GetBytes(szPostData);
            hr.ContentLength = rgbData.Length;
            using (Stream s = hr.GetRequestStream())
            {
                s.Write(rgbData, 0, rgbData.Length);
            }

            using (WebResponse response = hr.GetResponse())
            {
                using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                {
                    string result = sr.ReadToEnd();

                    // JSonConvert can't deserialize space-delimited scopes into a hashset, so we need to do that manually.  Uggh.
                    Dictionary<string, string> d = JsonConvert.DeserializeObject<Dictionary<string, string>>(result);

                    AuthorizationState authstate = new AuthorizationState(d.TryGetValue("scope", out string scopes) ? OAuthUtilities.SplitScopes(scopes) : null)
                    {
                        AccessToken = d.TryGetValue("access_token", out string acctok) ? acctok : string.Empty,
                        AccessTokenIssueDateUtc = DateTime.UtcNow
                    };
                    if (d.TryGetValue("expires_in", out string value))
                    {
                        if (int.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out int exp))
                            authstate.AccessTokenExpirationUtc = DateTime.UtcNow.AddSeconds(exp);
                    }
                    authstate.RefreshToken = d.TryGetValue("refresh_token", out string reftok) ? reftok : string.Empty;

                    return authstate;
                }
            }
        }

        public override IAuthorizationState ConvertToken(HttpRequest Request)
        {
            return ConvertToken(new HttpRequestWrapper(Request));
        }
    }

    /// <summary>
    /// Provides utilities for using GoogleDrive from MyFlightbook
    /// </summary>
    public class GoogleDrive : GoogleOAuthBase
    {
        public const string szParamGDriveAuth = "gdOAuth";

        private const string szURLUploadEndpoint = "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart";
        private const string szURLUpdateEndpointTemplate = "https://www.googleapis.com/upload/drive/v3/files/{0}?uploadType=multipart";
        private const string szURLViewFilesEndpointTemplate = "https://www.googleapis.com/drive/v3/files?q={0}&key={1}";

        // The google ID of the root folder where we place files.
        private string RootFolderID { get; set; }

        private readonly static string[] driveScopes = new string[] { "https://www.googleapis.com/auth/drive.file" };

        public GoogleDrive(Profile pf = null)
            : base("GoogleDriveAccessID", "GoogleDriveClientSecret", "https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent", "https://www.googleapis.com/oauth2/v4/token", driveScopes)
        {
            AuthParam = szParamGDriveAuth;
            // Issue #1067: put everything under a single root
            // Root path uses backslashes here and is either just the brand name ("MyFlightbook") or it is Brand\year\month.
            RootPath = Branding.CurrentBrand.AppName + (UserUsesFlatHierarchy(pf) ? string.Empty : DateTime.Now.ToString("\\\\yyyy\\\\MM-MMMM", CultureInfo.CurrentCulture));
            RootFolderID = string.Empty;
            CurrentUser = pf;
            AuthState = pf?.GoogleDriveAccessToken;
        }

        protected async Task<string> CreateFolder(string szFolderName, string parentID)
        {
            // Create the metadata.  Name is most important, but we can also specify mimeType for CSV to import into GoogleDocs
            Dictionary<string, object> dictMeta = new Dictionary<string, object>() { { "name", szFolderName }, { "mimeType", "application/vnd.google-apps.folder" } };

            if (!String.IsNullOrEmpty(parentID))
                dictMeta["parents"] = new string[] { parentID };

            // Create the form.  The form itself needs the authtoken header
            using (MultipartContent form = new MultipartContent("related"))
            {
                // Next add the metadata - it is in Json format
                using (StringContent metadata = new StringContent(JsonConvert.SerializeObject(dictMeta)))
                {
                    metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json");
                    form.Add(metadata);

                    return (string)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri(szURLUploadEndpoint), AuthState.AccessToken, form, (response) =>
                    {
                        string szResult = string.Empty;
                        try
                        {
                            szResult = response.Content.ReadAsStringAsync().Result;
                            response.EnsureSuccessStatusCode();
                            if (!String.IsNullOrEmpty(szResult))
                            {
                                GoogleDriveFileMetadata gfm = JsonConvert.DeserializeObject<GoogleDriveFileMetadata>(szResult);
                                if (gfm != null)
                                    return gfm.id;
                            }
                            throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "Unknown result '{0}' returned trying to create folder named '{1}'", szResult, szFolderName));
                        }
                        catch (HttpRequestException ex)
                        {
                            if (response == null)
                                throw new MyFlightbookException("Unknown error in GoogleDrive.CreateFolder", ex);
                            else
                                throw new MyFlightbookException(response.ReasonPhrase + " " + szResult);
                        }
                    });
                }
            }
        }

        #region Finding files and folders on GoogleDrive
        /// <summary>
        /// Returns the URL-based query for Google drive to look for a folder with the specified name
        /// </summary>
        /// <param name="szFolderName">The name of the folder</param>
        /// <returns>The ID of the resulting object (if found)</returns>
        private static string FolderQuery(string szFolderName, string parentID)
        {
            return String.Format(CultureInfo.InvariantCulture, "name%3D%27{0}%27%20and%20trashed%3Dfalse%20and%20mimeType%3D%27application%2Fvnd.google-apps.folder%27", szFolderName) + (String.IsNullOrEmpty(parentID) ? string.Empty : String.Format(CultureInfo.InvariantCulture, "%20and%20%27{0}%27%20in%20parents", parentID));
        }

        /// <summary>
        /// Returns the ID of the leaf of the specified path, creating any folders as needed.
        /// E.g., if you want to put files into "MyFlightbook/2023/08-August", pass ["MyFlightbook", "2023", "08-August"].
        /// If any of those don't exist, they will be created; the id for "08-August" will be returned.
        /// </summary>
        /// <param name="path">An enumerable of folders</param>
        /// <returns>The ID of the leaf node</returns>
        protected async Task<string> GetLeafFolderForPath(IEnumerable<string> path)
        {
            if (path == null)
                return null;

            string lastParentID = null;

            foreach (string folder in path)
            {
                string folderID = await IDForFolder(folder, lastParentID);
                // Create the folder if it wasn't found, under the most recently created parent.
                lastParentID = String.IsNullOrEmpty(folderID) ? await CreateFolder(folder, lastParentID) : folderID;
            }
            return lastParentID;
        }

        /// <summary>
        /// Returns the URL-based query for Google drive to look for a file with the specified name
        /// </summary>
        /// <param name="szFileName">The name of the file</param>
        /// <param name="szParent">The ID of the parent folder</param>
        /// <returns>The ID of the resulting object (if found)</returns>
        protected static string FileQuery(string szFileName, string szParent)
        {
            return String.Format(CultureInfo.InvariantCulture, "name%3D%27{0}%27%20and%20%27{1}%27%20in%20parents%20and%20trashed%3Dfalse", szFileName, szParent);
        }

        /// <summary>
        /// Executes the specified search query, returning the ID of the first object that is found
        /// </summary>
        /// <param name="szQuery">Query (use FolderQuery or FileQuery)</param>
        /// <returns>The ID of the resulting object (if found), else string.empty</returns>
        protected async Task<string> FindIDForQuery(string szQuery)
        {
            // See if the folder exists
            Uri uri = new Uri(String.Format(CultureInfo.InvariantCulture, szURLViewFilesEndpointTemplate, szQuery, AppKey));

            return (string)await SharedHttpClient.GetResponseForAuthenticatedUri(uri, AuthState.AccessToken, HttpMethod.Get, (response) =>
            {
                string szResult = string.Empty;
                try
                {
                    szResult = response.Content.ReadAsStringAsync().Result;
                    response.EnsureSuccessStatusCode();
                    if (!String.IsNullOrEmpty(szResult))
                    {
                        GoogleFileList gfl = JsonConvert.DeserializeObject<GoogleFileList>(szResult);
                        if (gfl != null && gfl.files.Count > 0)
                            return gfl.files[0].id;
                    }
                    return string.Empty;
                }
                catch (HttpRequestException ex)
                {
                    if (response == null)
                        throw new MyFlightbookException("Unknown error in GoogleDrive.GetFolderID", ex);
                    else
                    {
                        Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                        GoogleDriveError gde = (d == null || !d.TryGetValue("error", out GoogleDriveError value)) ? null : value;
                        if (gde == null || gde.errors.Count == 0)
                            throw new MyFlightbookException(response.ReasonPhrase);
                        else
                            throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "{0} {1}: {2} (Query: {3})", response.ReasonPhrase, gde.errors[0].reason, gde.errors[0].message, szQuery));
                    }
                }
            });
        }

        protected async Task<string> IDForFolder(string szFoldername, string parentID)
        {
            return await FindIDForQuery(FolderQuery(szFoldername, parentID)).ConfigureAwait(false);
        }

        protected async Task<string> IDForFile(string szFileName, string szParentID)
        {
            return await FindIDForQuery(FileQuery(szFileName, szParentID)).ConfigureAwait(false);
        }
        #endregion

        private static void ThrowGDriveError(Exception ex)
        {
            if (ex == null)
                return;
            GDriveError error = JsonConvert.DeserializeObject<GDriveError>(ExtractResponseString(ex.InnerException as WebException));
            if (error == null)
                throw new MyFlightbookException("Unknown error refreshing access token", ex);
            else if (error.error.CompareCurrentCultureIgnoreCase("invalid_grant") == 0)
                throw new UnauthorizedAccessException(Branding.ReBrand(Resources.LocalizedText.GoogleDriveBadAuth), ex);
            else
                throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "Error from Google Drive: {0} {1} {2}", error.error, error.error_description, error.error_link), ex);
        }

        private static readonly char[] backslashes = new char[] { '\\' };

        /// <summary>
        /// Puts a file as a stream using the REST API documented at https://developers.google.com/drive/v3/web/manage-uploads#multipart
        /// </summary>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="ms">The stream of the data</param>
        /// <param name="szMimeType">The mime type for the data</param>
        /// <returns>True for success</returns>
        /// <exception cref="MyFlightbookException"></exception>
        /// <exception cref="System.Net.Http.HttpRequestException"></exception>
        public async Task<GoogleDriveResultDictionary> PutFile(string szFileName, Stream ms, string szMimeType)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));

            try
            {
                if (await RefreshAccessToken().ConfigureAwait(false) && CurrentUser != null)
                {
                    CurrentUser.GoogleDriveAccessToken = AuthState;
                    CurrentUser.FCommit();
                }
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException ex)
            {
                ThrowGDriveError(ex);
            }

            bool fIsCSV = szMimeType.CompareCurrentCultureIgnoreCase("text/csv") == 0;

            ms.Seek(0, SeekOrigin.Begin);   // write out the whole stream.  UploadAsync appears to pick up from the current location, which is the end-of-file after writing to a ZIP.

            if (String.IsNullOrEmpty(RootFolderID))
                RootFolderID = await GetLeafFolderForPath(RootPath.Split(backslashes, StringSplitOptions.RemoveEmptyEntries));

            // CSV loses its extension when uploaded because we map it to a google spreadsheet.  So if it's CSV AND we are patching an existing file, drop the extension so that we ov
            // update the existing file if it is present.  If CSV, strip the extension
            string szFileNameToCheck = fIsCSV ? Path.GetFileNameWithoutExtension(szFileName) : szFileName;
            string idExisting = null;
            if (!String.IsNullOrEmpty(RootFolderID))
                idExisting = await IDForFile(szFileNameToCheck, RootFolderID).ConfigureAwait(false);

            // If we got a hit, use that filename for the udpate
            if (!String.IsNullOrEmpty(idExisting))
                szFileName = szFileNameToCheck;

            // Create the metadata.  Name is most important, but we can also specify mimeType for CSV to import into GoogleDocs
            Dictionary<string, object> dictMeta = new Dictionary<string, object>() { { "name", szFileName } };
            if (fIsCSV)
                dictMeta["mimeType"] = "application/vnd.google-apps.spreadsheet";   // get it to show up in google drive sheets.
            if (String.IsNullOrEmpty(idExisting) && !String.IsNullOrEmpty(RootFolderID))
                dictMeta["parents"] = new List<string>() { RootFolderID };

            return await SendForm(AuthState.AccessToken, ms, dictMeta, szMimeType, idExisting).ConfigureAwait(false);
        }

        private static async Task<GoogleDriveResultDictionary> SendForm(string szToken, Stream ms, Dictionary<string, object> dictMeta, string szMimeType, string idExisting)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));

            int cRetry = 0;     // # of attempts that have been made so far
            const int MaxRetry = 3; // maximum number of attempts

            GoogleDriveResultDictionary result = null;

            // Write the memory stream to a file so that we can do exponential backoff, since we'll end up closing the stream.

            while (cRetry++ < MaxRetry)
            {
                // Create the form.  The form itself needs the authtoken header
                using (MultipartContent form = new MultipartContent("related"))
                {
                    // Next add the metadata - it is in Json format
                    string szJSonMeta = JsonConvert.SerializeObject(dictMeta);
                    using (StringContent metadata = new StringContent(szJSonMeta, System.Text.Encoding.UTF8))
                    {
                        metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json") { CharSet = "UTF-8" };
                        form.Add(metadata);

                        using (FileStream fs = new FileStream(Path.GetTempFileName(), FileMode.Open, FileAccess.ReadWrite, FileShare.None, Int16.MaxValue, FileOptions.DeleteOnClose))
                        {
                            // copy from the filestream to a new temp file, so that we can do exponential backoff if needed.
                            ms.Seek(0, SeekOrigin.Begin);   // write out the whole file!
                            ms.CopyTo(fs);
                            fs.Seek(0, SeekOrigin.Begin);

                            // Finally, add the body, with its appropriate mime type.
                            using (StreamContent body = new StreamContent(fs))
                            {
                                body.Headers.ContentType = new MediaTypeHeaderValue(szMimeType);
                                form.Add(body);

                                bool fExisting = !String.IsNullOrEmpty(idExisting);
                                Uri Target = fExisting ? new Uri(String.Format(CultureInfo.InvariantCulture, szURLUpdateEndpointTemplate, idExisting)) : new Uri(szURLUploadEndpoint);
                                HttpMethod method = fExisting ? new HttpMethod("PATCH") : HttpMethod.Post;

                                result = (GoogleDriveResultDictionary)await SharedHttpClient.GetResponseForAuthenticatedUri(Target, szToken, method, form, (response) =>
                                {
                                    string szResult = string.Empty;

                                    try
                                    {
                                        szResult = response.Content.ReadAsStringAsync().Result;
                                        // DEBUG: szResult = "{\"error\": {\"errors\": [{\"domain\": \"usageLimits\",\"reason\": \"userRateLimitExceeded\",\"message\": \"User rate limit exceeded.\"}],\"code\": 403,\"message\": \"User rate limit exceeded.\"}}";
                                        // DEBUG: throw new HttpRequestException(szResult);
                                        response.EnsureSuccessStatusCode();
                                        return String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<GoogleDriveResultDictionary>(szResult);
                                    }
                                    catch (HttpRequestException ex)
                                    {
                                        if (response == null)
                                            throw new MyFlightbookException("Unknown error in GoogleDrive.PutFile", ex);

                                        Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                                        GoogleDriveError gde = (d == null || !d.TryGetValue("error", out GoogleDriveError value)) ? null : value;

                                        bool fHasReason = gde != null && gde.errors != null && gde.errors.Count > 0 && gde.errors[0].reason != null;
                                        if (fHasReason)
                                        {
                                            if (gde.code == 403)
                                            {
                                                if (gde.errors[0].reason.CompareCurrentCultureIgnoreCase("storageQuotaExceeded") == 0)
                                                    throw new MyFlightbookException(Resources.LocalizedText.GoogleDriveOutOfSpace);
                                                else if (gde.errors[0].reason.CompareCurrentCultureIgnoreCase("userRateLimitExceeded") == 0)
                                                {
                                                    if (cRetry < MaxRetry)
                                                    {
                                                        // exponential backoff.
                                                        System.Threading.Thread.Sleep(1000 * (1 << (cRetry - 1)));
                                                        // fall through, we'll try again.
                                                        return null;
                                                    }
                                                    else // too many attempts - just report that as an error.
                                                        throw new MyFlightbookException(gde.message);
                                                }
                                            }

                                            // We have a GoogleDrive error, but it was not a 403 or it was not quota/ratelimit.
                                            throw new MyFlightbookException(response.ReasonPhrase + " " + gde.errors[0].reason + ": " + gde.errors[0].message ?? string.Empty);
                                        }
                                        else
                                            throw new MyFlightbookException(response.ReasonPhrase + " " + (szResult ?? string.Empty));
                                    }
                                });
                            }
                        }
                    }
                }

                if (result != null || cRetry >= MaxRetry)
                    break;
            }

            return result;
        }
    }
    #endregion

    #region Box
    public class BoxDrive : CloudStorageBase
    {
        // Root myDeserializedClass = JsonConvert.DeserializeObject<Root>(myJsonResponse);
        [Serializable]
        public class BoxItem
        {
            public string id { get; set; }
            public string etag { get; set; }
            public string type { get; set; }
            public string sequence_id { get; set; }
            public string name { get; set; }
        }

        [Serializable]
        public class BoxEntriesResponse
        {
            public BoxEntry[] entries { get; set; }
            public int limit { get; set; }
            public int offset { get; set; }
            public string next_marker { get; set; } = string.Empty;
            public string prev_marker { get; set; } = string.Empty;
            int total_count { get; set; }
            BoxOrder[] order { get; set; } = Array.Empty<BoxOrder>();
        }

        [Serializable]
        public class BoxOrder
        {
            public string by { get; set; } = string.Empty;
            public string direction { get; set; } = "ASC";
        }

        [Serializable]
        public class BoxUser
        {
            public string id { get; set; }
            public string type { get; set; }
            public string name { get; set; }
            public string login { get; set; }
        }

        [Serializable]
        public class BoxEntry : BoxItem
        {
            public string sha1 { get; set; }
            public string description { get; set; }
            public int size { get; set; }
            public DateTime? created_at { get; set; }
            public DateTime? modified_at { get; set; }
            public DateTime? trashed_at { get; set; }
            public DateTime? purged_at { get; set; }
            public DateTime? content_created_at { get; set; }
            public DateTime? content_modified_at { get; set; }
            public BoxUser created_by { get; set; }
            public BoxUser modified_by { get; set; }
            public BoxUser owned_by { get; set; }
            public BoxEntry parent { get; set; }
            public string item_status { get; set; }
            public string version_number { get; set; }
            public int comment_count { get; set; }
            public BoxItemPermissions permissions { get; set; }
            public List<string> tags { get; set; }
            public string extension { get; set; }
            public bool is_package { get; set; }
            public bool is_accessible_via_shared_link { get; set; }
            public List<string> allowed_invitee_roles { get; set; }
            public bool is_externally_owned { get; set; }
            public bool has_collaborations { get; set; }
            public DateTime? expires_at { get; set; }
            public string uploader_display_name { get; set; }
            public DateTime? disposition_at { get; set; }
            public List<string> shared_link_permission_options { get; set; }
        }

        [Serializable]
        public class BoxItemPermissions
        {
            public bool can_download { get; set; }
            public bool can_preview { get; set; }
            public bool can_edit { get; set; }
            public bool can_delete { get; set; }
            public bool can_invite_collaborator { get; set; }
            public bool can_rename { get; set; }
            public bool can_set_share_access { get; set; }
            public bool can_share { get; set; }
            public bool can_annotate { get; set; }
            public bool can_comment { get; set; }
            public bool can_upload { get; set; }
            public bool can_view_annotations_all { get; set; }
            public bool can_view_annotations_self { get; set; }
        }

        [Serializable]
        public class BoxResponseError
        {
            public string type { get; set; } = string.Empty;
            public string status { get; set; } = string.Empty;
            public string code { get; set; } = string.Empty;
#pragma warning disable CA1056 // URI-like properties should not be strings
            public string help_url { get; set; } = string.Empty;
#pragma warning restore CA1056 // URI-like properties should not be strings
            public string message { get; set; } = string.Empty;
            public string request_id { get; set; } = string.Empty;
        }

        public class BoxResponseException : Exception
        {
            public BoxResponseError BoxError { get; private set; }

            public BoxResponseException(BoxResponseError err = null, Exception exception = null) : base(err?.message ?? string.Empty, exception) { BoxError = err; }
        }

        [Serializable]
        public class BoxUploadSessionEndpoints
        {
            public string abort { get; set; }
            public string commit { get; set; }
            public string list_parts { get; set; }
            public string log_event { get; set; }
            public string status { get; set; }
            public string upload_part { get; set; }
        }

        [Serializable]
        public class BoxUploadSession
        {
            public string id { get; set; }
            public string type { get; set; }
            public int num_parts_processed { get; set; }
            public int part_size { get; set; }
            public DateTime? session_expires_at { get; set; }
            public int total_parts { get; set; }
            public BoxUploadSessionEndpoints session_endpoints { get; set; }
        }

        [Serializable]
        public class BoxUploadPartDescription
        {
            public long offset { get; set; }
            public string part_id { get; set; }
            public string sha1 { get; set; }
            public long size { get; set; }
        }

        [Serializable]
        public class BoxUploadPartResponse
        {
            public BoxUploadPartDescription part { get; set; }
        }

        public const string PrefKeyBoxAuthToken = "BoxAuthToken";

        public BoxDrive(Profile pf = null) : base("BoxClientID", "BoxClientSecret", "https://account.box.com/api/oauth2/authorize", "https://api.box.com/oauth2/token", Array.Empty<string>(), null, null)
        {
            RootPath = UserUsesFlatHierarchy(pf) ? Branding.CurrentBrand.AppName + "/" : String.Format(CultureInfo.InvariantCulture, "{0}/{1}/{2}/", Branding.CurrentBrand.AppName, DateTime.Now.ToString("yyyy", CultureInfo.CurrentCulture), DateTime.Now.ToString("MM-MMMM", CultureInfo.CurrentCulture));
            CurrentUser = pf;
            AuthState = pf?.GetPreferenceForKey<AuthorizationState>(PrefKeyBoxAuthToken);
        }

        private async Task<BoxUploadSession> GetResumableSession(string file_name, long file_size, string folder_id, BoxItem existingItem)
        {
            string szEndpoint = existingItem == null ? "https://upload.box.com/api/2.0/files/upload_sessions" : String.Format(CultureInfo.InvariantCulture, "https://upload.box.com/api/2.0/files/{0}/upload_sessions", existingItem.id);
            string objJSON = existingItem == null ? JsonConvert.SerializeObject(new { file_name, file_size, folder_id }) : JsonConvert.SerializeObject(new { file_size });
            using (StringContent metadata = new StringContent(objJSON))
            {
                metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json");
                return (BoxUploadSession)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri(szEndpoint), AuthState.AccessToken, HttpMethod.Post, metadata, (response) =>
                {
                    string szResult = null;
                    try
                    {
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        return JsonConvert.DeserializeObject<BoxUploadSession>(szResult);
                    }
                    catch (HttpRequestException ex)
                    {
                        BoxResponseError b = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<BoxResponseError>(szResult);
                        throw new BoxResponseException(b, ex);
                    }
                });
            }
        }

        private const int chunkThreshold = 20000000; // size above which we will do chunked uploads

        private async Task<string> PutFileChunked(string szFileName, Stream ms, string parent, BoxItem existingItem)
        {
            long totalBytes = ms.Length;
            int startingByte = 0;

            BoxUploadSession bus = await GetResumableSession(szFileName, totalBytes, parent, existingItem);

            List<BoxUploadPartDescription> lstParts = new List<BoxUploadPartDescription>();

            using (var sha1 = SHA1.Create())
            {
                ms.Seek(0, SeekOrigin.Begin);

                bool fContinue = true;
                Uri uploadEndpoint = new Uri(bus.session_endpoints.upload_part);
                while (fContinue)
                {
                    int chunkSize = Math.Min((int)totalBytes - startingByte, bus.part_size);
                    byte[] uploadChunk = new byte[chunkSize];
                    int cBytes = ms.Read(uploadChunk, 0, chunkSize);

                    using (ByteArrayContent bac = new ByteArrayContent(uploadChunk))
                    {
                        bac.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
                        bac.Headers.ContentRange = new ContentRangeHeaderValue(startingByte, startingByte + cBytes - 1, totalBytes);
                        bac.Headers.Add("digest", "sha=" + Convert.ToBase64String(sha1.ComputeHash(uploadChunk, 0, cBytes)));
                        fContinue = (bool)await SharedHttpClient.GetResponseForAuthenticatedUri(uploadEndpoint, AuthState.AccessToken, HttpMethod.Put, bac, (response) =>
                        {
                            string szResult = string.Empty;
                            try
                            {
                                szResult = response.Content.ReadAsStringAsync().Result;
                                response.EnsureSuccessStatusCode();
                                // success!
                                BoxUploadPartResponse partResponse = JsonConvert.DeserializeObject<BoxUploadPartResponse>(szResult);
                                lstParts.Add(partResponse.part);
                                startingByte += cBytes;
                                return (totalBytes - startingByte) > 0;
                            }
                            catch (HttpRequestException ex)
                            {
                                if (response == null || String.IsNullOrEmpty(szResult))
                                    throw new MyFlightbookException("Unknown error in Box.put file chunked - " + response.ReasonPhrase, ex);
                                else
                                    throw new BoxResponseException(JsonConvert.DeserializeObject<BoxResponseError>(szResult), ex);
                            }
                        });
                    }
                }

                ms.Seek(0, SeekOrigin.Begin);
                string shaFull = "sha=" + Convert.ToBase64String(sha1.ComputeHash(ms));

                string szParts = JsonConvert.SerializeObject(new { parts = lstParts });
                // Finally commit the session
                using (StringContent sc = new StringContent(szParts))
                {
                    sc.Headers.Add("digest", shaFull);
                    sc.Headers.ContentType = new MediaTypeHeaderValue("application/json");
                    return (string)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri(bus.session_endpoints.commit), AuthState.AccessToken, HttpMethod.Post, sc, (response) =>
                    {
                        string szResult = string.Empty;
                        try
                        {
                            szResult = response.Content.ReadAsStringAsync().Result;
                            response.EnsureSuccessStatusCode();
                            // success!
                            return string.Empty;
                        }
                        catch (HttpRequestException ex)
                        {
                            if (response == null || String.IsNullOrEmpty(szResult))
                                throw new MyFlightbookException("Unknown error in Box.commit file chunked - " + response.ReasonPhrase, ex);
                            else
                                throw new BoxResponseException(JsonConvert.DeserializeObject<BoxResponseError>(szResult), ex);
                        }
                    });
                }
            }
        }

        public async Task<string> PutFile(string szFileName, Stream ms)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));

            if (CurrentUser != null && !CheckAccessToken())
            {
                AuthState = await RefreshAccessToken(AuthState.RefreshToken, AuthState.Callback.ToString()).ConfigureAwait(false);
                CurrentUser.SetPreferenceForKey(PrefKeyBoxAuthToken, AuthState);
                CurrentUser.FCommit();
            }

            IEnumerable<string> segments = UserUsesFlatHierarchy(CurrentUser) ? new string[] { Branding.CurrentBrand.AppName } : new string[] { Branding.CurrentBrand.AppName, DateTime.Now.Year.ToString(CultureInfo.CurrentCulture), DateTime.Now.ToString("MM-MMMM", CultureInfo.CurrentCulture) };
            string parent = await CreatePath(segments);
            ms.Seek(0, SeekOrigin.Begin);

            // see if this item already exists - that determines if we're doing an upload or an update
            BoxItem existingItem = await FindItem(szFileName, parent, false);

            if (ms.Length > chunkThreshold)
                return await PutFileChunked(szFileName, ms, parent, existingItem);

            string szEndpoint = existingItem == null ? "https://upload.box.com/api/2.0/files/content" : String.Format(CultureInfo.InvariantCulture, "https://upload.box.com/api/2.0/files/{0}/content", existingItem.id);
            using (MultipartFormDataContent form = new MultipartFormDataContent())
            {
                using (StreamContent streamcontent = new StreamContent(ms))
                {
                    form.Add(streamcontent, "file", szFileName);
                    using (StringContent metadata = new StringContent(JsonConvert.SerializeObject(new { name = szFileName, parent = new { id = parent } })))
                    {
                        form.Add(metadata, "attributes");

                        return (string)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri(szEndpoint), AuthState.AccessToken, HttpMethod.Post, form, (response) =>
                        {
                            string szResult = string.Empty;
                            try
                            {
                                szResult = response.Content.ReadAsStringAsync().Result;
                                response.EnsureSuccessStatusCode();
                                // success!
                                return string.Empty;
                            }
                            catch (HttpRequestException ex)
                            {
                                if (response == null || String.IsNullOrEmpty(szResult))
                                    throw new MyFlightbookException("Unknown error in Box.putfile - " + response.ReasonPhrase, ex);
                                else
                                    throw new BoxResponseException(JsonConvert.DeserializeObject<BoxResponseError>(szResult), ex);
                            }
                        });
                    }
                }
            }
        }

        private async Task<BoxItem> FindItem(string resourceName, string parent, bool fFolder)
        {
            string resourceType = fFolder ? "folder" : "file";
            NameValueCollection nvc = HttpUtility.ParseQueryString(string.Empty);
            nvc["type"] = resourceType;
            nvc["ancestor_folder_ids"] = parent;
            nvc["query"] = resourceName;
            return (BoxItem)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri(String.Format(CultureInfo.InvariantCulture, "https://api.box.com/2.0/search?{0}", nvc.ToString())), AuthState.AccessToken, HttpMethod.Get, (response) =>
            {
                string szResult = null;
                try
                {
                    szResult = response.Content.ReadAsStringAsync().Result;
                    response.EnsureSuccessStatusCode();
                    BoxEntriesResponse boxResponse = JsonConvert.DeserializeObject<BoxEntriesResponse>(szResult);
                    List<BoxEntry> entryList = new List<BoxEntry>(boxResponse.entries);
                    return entryList.FirstOrDefault(bi => bi.type.CompareCurrentCultureIgnoreCase(resourceType) == 0 && bi.name.CompareCurrentCultureIgnoreCase(resourceName) == 0 && bi.parent.id.CompareCurrentCultureIgnoreCase(parent) == 0);
                }
                catch (HttpRequestException ex)
                {
                    BoxResponseError b = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<BoxResponseError>(szResult);
                    // Check for not found - that's not really an exception; just means we may need to create the folder.
                    if (b.status.CompareCurrentCultureIgnoreCase("404") == 0 || b.code.CompareCurrentCultureIgnoreCase("not_found") == 0)
                        return null;
                    throw new BoxResponseException(b, ex);
                }
            });
        }

        private async Task<BoxItem> CreateFolder(string folder, string parent)
        {
            using (StringContent metadata = new StringContent(JsonConvert.SerializeObject(new { name = folder, parent = new { id = parent } })))
            {
                metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json");
                return (BoxItem)await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri("https://api.box.com/2.0/folders"), AuthState.AccessToken, HttpMethod.Post, metadata, (response) =>
                {
                    string szResult = null;
                    try
                    {
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        return JsonConvert.DeserializeObject<BoxEntry>(szResult);
                    }

                    catch (HttpRequestException ex)
                    {
                        if (response == null || String.IsNullOrEmpty(szResult))
                            throw new MyFlightbookException("Unknown error in Box.putfile - " + response.ReasonPhrase, ex);
                        else
                            throw new BoxResponseException(JsonConvert.DeserializeObject<BoxResponseError>(szResult), ex);
                    }
                });
            }
        }

        private async Task<string> CreatePath(IEnumerable<string> segments)
        {
            if (segments == null)
                throw new ArgumentNullException(nameof(segments));

            string parentID = "0";

            // Start at the root
            foreach (string segment in segments)
            {
                BoxItem bi = await FindItem(segment, parentID, true) ?? await CreateFolder(segment, parentID);
                parentID = bi.id;
            }
            return parentID;
        }
    }
    #endregion

    #region OneDrive
    public enum OneDriveErrorCodeMFB
    {
        Unknown = -1,
        AccessDenied = 0,
        ActivityLimitReached = 1,
        AuthenticationCancelled = 2,
        AuthenticationFailure = 3,
        GeneralException = 4,
        InvalidRange = 5,
        InvalidRequest = 6,
        ItemNotFound = 7,
        MalwareDetected = 8,
        MyFilesCapabilityNotFound = 9,
        NameAlreadyExists = 10,
        NotAllowed = 11,
        NotSupported = 12,
        ResourceModified = 13,
        ResyncRequired = 14,
        ServiceNotAvailable = 15,
        Timeout = 16,
        TooManyRedirects = 17,
        QuotaLimitReached = 18,
        Unauthenticated = 19,
        UserDoesNotHaveMyFilesService = 20
    }

    public class OneDriveError
    {
        OneDriveErrorCodeMFB ErrorCode { get; set; }

        public string Message { get; set; }

        public OneDriveError(OneDriveErrorCodeMFB errCode)
        {
            ErrorCode = errCode;
            Message = MessageForCode(errCode, string.Empty);
        }

        protected static string MessageForCode(OneDriveErrorCodeMFB errCode, string szDefault)
        {
            switch (errCode)
            {
                case OneDriveErrorCodeMFB.AccessDenied:
                case OneDriveErrorCodeMFB.AuthenticationCancelled:
                case OneDriveErrorCodeMFB.AuthenticationFailure:
                case OneDriveErrorCodeMFB.Unauthenticated:
                    return Branding.ReBrand(Resources.LocalizedText.OneDriveBadAuth);
                case OneDriveErrorCodeMFB.QuotaLimitReached:
                    return Resources.LocalizedText.OneDriveErrorOutOfSpace;
                case OneDriveErrorCodeMFB.Timeout:
                case OneDriveErrorCodeMFB.ServiceNotAvailable:
                case OneDriveErrorCodeMFB.TooManyRedirects:
                    return Resources.LocalizedText.OneDriveCantReachService;
                default:
                    return String.Format(CultureInfo.CurrentCulture, "{0} {1}", errCode.ToString(), String.IsNullOrEmpty(szDefault) ? string.Empty : String.Format(CultureInfo.CurrentCulture, "({0})", szDefault));
            }
        }

        public OneDriveError(string szJSon) : base()
        {
            Message = string.Empty;
            ErrorCode = OneDriveErrorCodeMFB.Unknown;

            if (String.IsNullOrEmpty(szJSon))
                return;

            try
            {
                dynamic result = JObject.Parse(szJSon);
                if (Enum.TryParse((string) result.error.code, true, out OneDriveErrorCodeMFB errCode))
                {
                    ErrorCode = errCode;
                    Message = MessageForCode(ErrorCode, (string) result.error.message);
                }
                else
                    Message = String.Format(CultureInfo.CurrentCulture, "{0} (OneDrive returned: {1})", result.error.message, szJSon);
            }
            catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException)
            {
                Message = String.Format(CultureInfo.InvariantCulture, "Error in OneDrive response: {0}", szJSon);
            }
            catch (JsonReaderException)
            {
                Message = String.Format(CultureInfo.InvariantCulture, "Invalid response from OneDrive: {0}", szJSon);
            }
        }

        public override string ToString()
        {
            return String.Format(CultureInfo.CurrentCulture, "{0}: {1}", ErrorCode, Message);
        }
    }

    [Serializable]
    public class OneDriveMFBException : Exception
    {
        public OneDriveError Error { get; set; }
        public OneDriveMFBException(string message) : base(message)
        {
            Error = null;
        }

        public OneDriveMFBException(string message, Exception innerException) : base(message, innerException)
        {
            Error = null;
        }

        public OneDriveMFBException(OneDriveError err) : base(err == null ? string.Empty : err.Message)
        {
            Error = err;
        }
            
        public OneDriveMFBException(OneDriveError err, Exception innerException) : base(err == null ? string.Empty : err.Message, innerException)
        {
            Error = err;
        }

        public OneDriveMFBException()
        {
            Error = null;
        }

        protected OneDriveMFBException(SerializationInfo serializationInfo, StreamingContext streamingContext): base(serializationInfo, streamingContext)
        {
            Error = null;
        }

        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);

            info.AddValue("Error", Error);
        }
    }

    internal class OneDriveSession
    {
        [JsonProperty("uploadUrl")]
        public string UploadEndpoint { get; set; }

        public Uri UploadUri
        {
            get { return new Uri(UploadEndpoint ?? string.Empty); }
        }

        [JsonProperty("expirationDateTime")]
        public DateTime Expiration { get; set; }

        [JsonProperty("nextExpectedRanges")]
        public Collection<string> ExpectedRanges { get; set; }

        public OneDriveSession()
        {
            UploadEndpoint = string.Empty;
            ExpectedRanges = new Collection<string>();
            Expiration = DateTime.MinValue;
        }
    }

    /// <summary>
    /// Provides utilities for using OneDrive from MyFlightbook
    /// 
    /// Useful resources:
    ///   - oAuth flow and endpoints: https://dev.onedrive.com/auth/msa_oauth.htm
    ///   - Rest API for uploading: https://docs.microsoft.com/en-us/onedrive/developer/rest-api/concepts/upload?view=odsp-graph-online
    /// </summary>
    public class OneDrive : CloudStorageBase
    {
        public const string TokenSessionKey = "sessionkeyforonedrive";
        public const string szParam1DriveAuth = "1dOAuth";
        private const int MinFileSizeResumable = 4000000;   // files that are 4MB+ require a resumable upload.
        private static readonly string[] _scopes = new string[] { "onedrive.appfolder", "wl.basic", "onedrive.readwrite", "wl.offline_access" };

        public OneDrive(Profile pf = null) 
            : base("OneDriveAccessID", "OneDriveClientSecret", "https://login.live.com/oauth20_authorize.srf", "https://login.live.com/oauth20_token.srf", _scopes)
        {
            RootPath = UserUsesFlatHierarchy(pf) ? Branding.CurrentBrand.AppName + "/" : String.Format(CultureInfo.InvariantCulture, "{0}/{1}/{2}/", Branding.CurrentBrand.AppName, DateTime.Now.ToString("yyyy", CultureInfo.CurrentCulture), DateTime.Now.ToString("MM-MMMM", CultureInfo.CurrentCulture));
            CurrentUser = pf;
            AuthState = pf?.OneDriveAccessToken;
        }

        protected static void HandleInvalidAuth(Exception ex)
        {
            if (ex == null)
                throw new ArgumentNullException(nameof(ex));

            string szResponse = ExtractResponseString(ex.InnerException as WebException);
            try
            {
                dynamic error = JsonConvert.DeserializeObject(szResponse);
                if (error == null)
                    throw new MyFlightbookException("Unknown error refreshing access token", ex);
                else if (error.error != null && String.Compare(error.error.ToString(), "invalid_grant", StringComparison.InvariantCulture) == 0)
                {
                    OneDriveMFBException ode = new OneDriveMFBException(new OneDriveError(OneDriveErrorCodeMFB.AuthenticationFailure), ex);
                    throw new UnauthorizedAccessException(ode.Message, ode);
                }
                else
                    throw new MyFlightbookException(Branding.ReBrand(Resources.LocalizedText.OneDriveBadAuth));
            }
            catch (JsonReaderException ex2)
            {
                throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "Unable to deserialize response '{0}': {1}", szResponse, ex2.Message), ex);
            }
        }

        private static UriBuilder BuilderForPath(string szPath)
        {
            return new UriBuilder("https://api.onedrive.com")
            {
                Query = string.Empty,
                Path = szPath
            };
        }

        internal async Task<OneDriveSession> GetResumableSession(string szFilename)
        {
            string szResult = string.Empty;

            Dictionary<string, string> d = new Dictionary<string, string>()
                    {
                        { "@microsoft.graph.conflictBehavior", "replace" },
                        { "name", szFilename }
                    };
            Dictionary<string, object> d2 = new Dictionary<string, object>() { { "item", d } };
            using (StringContent sc = new StringContent(JsonConvert.SerializeObject(d2), System.Text.Encoding.UTF8, "application/json"))
            {
                UriBuilder builder = BuilderForPath(String.Format(CultureInfo.InvariantCulture, "v1.0/drive/root:/{0}{1}:/createUploadSession", RootPath, szFilename));

                return (OneDriveSession)await SharedHttpClient.GetResponseForAuthenticatedUri(builder.Uri, AuthState.AccessToken, sc, (response) =>
                {
                    try
                    {
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        // Deserialize (below) should never return null because EnsureSuccessStatusCode should throw an exception if there's an issue, but this suppresses a warning about uninstantiated OneDriveSession
                        return JsonConvert.DeserializeObject<OneDriveSession>(szResult) ?? new OneDriveSession();
                    }
                    catch (HttpRequestException ex)
                    {
                        if (response == null)
                            throw new MyFlightbookException("Unknown error in OneDrive.PutFileDirect", ex);
                        else
                            throw new OneDriveMFBException(new OneDriveError(szResult));
                    }
                });
            }
        }

        public async Task<bool> PutFileDirect(string szFilename, Stream ms, string szMimeType)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));
            ms.Seek(0, SeekOrigin.Begin);
            try
            {
                if (await RefreshAccessToken().ConfigureAwait(false) && CurrentUser != null)
                {
                    CurrentUser.OneDriveAccessToken = AuthState;
                    CurrentUser.FCommit();
                }
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException ex)
            {
                HandleInvalidAuth(ex);
            }

            string szResult = string.Empty;

            // See if we need to do a resumable session
            OneDriveSession session = (ms.Length > MinFileSizeResumable) ? await GetResumableSession(szFilename).ConfigureAwait(false) : null;

            using (StreamContent body = new StreamContent(ms))
            {
                body.Headers.ContentType = new MediaTypeHeaderValue(szMimeType);
                body.Headers.ContentDisposition = (new ContentDispositionHeaderValue("form-data") { Name = szFilename, FileName = szFilename });

                UriBuilder builder = BuilderForPath(String.Format(CultureInfo.InvariantCulture, "v1.0/drive/root:/{0}{1}:/content", RootPath, szFilename));
                if (session != null)
                {
                    body.Headers.ContentLength = ms.Length;
                    body.Headers.ContentRange = new ContentRangeHeaderValue(0, ms.Length - 1, ms.Length) { Unit = "bytes" };
                }

                return (bool)await SharedHttpClient.GetResponseForAuthenticatedUri(session == null ? builder.Uri : session.UploadUri, AuthState.AccessToken, HttpMethod.Put, body, (response) =>
                {
                    try
                    {
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        return !String.IsNullOrEmpty(szResult);
                    }
                    catch (HttpRequestException ex)
                    {
                        if (response == null)
                            throw new MyFlightbookException("Unknown error in OneDrive.PutFileDirect", ex);
                        else
                            throw new OneDriveMFBException(new OneDriveError(szResult));
                    }
                });
            }
        }

        public async Task<bool> PutFileDirect(string szFileName, byte[] rgData, string szMimeType)
        {
            using (MemoryStream ms = new MemoryStream(rgData))
            {
                return await PutFileDirect(szFileName, ms, szMimeType).ConfigureAwait(false);
            }
        }
    }
    #endregion

    #region Dropbox
    /// <summary>
    /// Provides utilities for using Dropbox from MyFlightbook
    /// </summary>
    public class MFBDropbox: CloudStorageBase
    {
        public enum TokenStatus { None, oAuth1, oAuth2 }
        public const string szParamDropboxAuth = "dbOAuth";
        private static readonly string[] _scopes = new string[] { "files.content.write", "files.content.read", "files.metadata.write", "files.metadata.read" };

        public MFBDropbox(Profile pf = null)
            : base("DropboxAccessID", "DropboxClientSecret", "https://www.dropbox.com/oauth2/authorize?token_access_type=offline", "https://api.dropboxapi.com/oauth2/token", 
                  _scopes, "https://api.dropboxapi.com/2/auth/token/from_oauth1", "https://api.dropboxapi.com/2/auth/token/revoke")
        {
            CurrentUser = pf;
            RootPath = UserUsesFlatHierarchy(pf) ? "/" : String.Format(CultureInfo.InvariantCulture, "/{0}/{1}/", DateTime.Now.ToString("yyyy", CultureInfo.CurrentCulture), DateTime.Now.ToString("MM-MMMM", CultureInfo.CurrentCulture));
        }

        /// <summary>
        /// Determines the type of dropbox oAuth token we have.  Optionally upgrades to an oAuth 2.0 credential and/or disables the existing one.
        /// MODIFIES THE IN MEMORY USER PROFILE to use an upgraded credential
        /// </summary>
        /// <param name="pf">The user profile</param>
        /// <param name="fCommit">True to update the database with the oAuth 2.0 credential</param>
        /// <returns>The state of the dropbox access token PRIOR to upgrade.</returns>
        async public Task<TokenStatus> ValidateDropboxToken()
        {
            TokenStatus result = TokenStatus.None;

            if (CurrentUser == null || String.IsNullOrEmpty(CurrentUser.DropboxAccessToken))
                return result;

            try
            {
                string dbAppKey = AppKey;
                string dbSecret = AppSecret;

                byte[] rgbOAuth1Token = Convert.FromBase64String(CurrentUser.DropboxAccessToken);
                string xmlOAuth1Token = System.Text.Encoding.Default.GetString(rgbOAuth1Token);
                // if we get here, it is probably an oAuth1 token

                if (xmlOAuth1Token.Trim().StartsWith("<", StringComparison.OrdinalIgnoreCase))
                {
                    string szRawToken = null;
                    string szRawSecret = null;

                    using (MemoryStream stream = new MemoryStream(rgbOAuth1Token))
                    {
                        DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<string, string>));
                        Object o = serializer.ReadObject(stream);
                        if (o.GetType().Equals(typeof(Dictionary<string, string>)))
                        {
                            Dictionary<string, string> d = (Dictionary<string, string>)o;
                            szRawToken = d["TokenDropBoxUsername"];
                            szRawSecret = d["TokenDropBoxPassword"];
                        }
                    }


                    try
                    {
                        using (DropboxAppClient client = new DropboxAppClient(dbAppKey, dbSecret))
                        {
                            var tokenFromOAuth1Result = await client.Auth.TokenFromOauth1Async(szRawToken, szRawSecret).ConfigureAwait(false);
                            CurrentUser.DropboxAccessToken = tokenFromOAuth1Result.Oauth2Token;
                        }

                        CurrentUser.FCommit();

                        result = TokenStatus.oAuth1;
                    }
                    catch (Exception ex) when (ex is WebException)
                    {
                    }
                }
                else
                    result = TokenStatus.oAuth2;
            }
            catch (Exception ex) when (ex is FormatException)
            {
                // It should be v2!
                result = TokenStatus.oAuth2;
            }
            return result;
        }

        /// <summary>
        /// Puts a file as an array of bytes
        /// </summary>
        /// <param name="szDropboxAccessToken">The oAuth 2.0 access token</param>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="rgData">The array of bytes</param>
        /// <returns>FileMetadata with the result</returns>
        public async Task<Dropbox.Api.Files.FileMetadata> PutFile(string szFileName, byte[] rgData)
        {
            using (MemoryStream ms = new MemoryStream(rgData))
            {
                return await PutFile(szFileName, ms).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Puts a file as a stream
        /// </summary>
        /// <param name="szDropboxAccessToken">The oAuth 2.0 access token</param>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="ms">The stream of the data</param>
        /// <returns>FileMetadata with the result</returns>
        public async Task<Dropbox.Api.Files.FileMetadata> PutFile(string szFileName, Stream ms)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));
            if (CurrentUser == null)
                throw new MyFlightbookValidationException("Can't put file without a user profile object");
            if (String.IsNullOrWhiteSpace(CurrentUser.DropboxAccessToken))
                throw new MyFlightbookValidationException(String.Format(CultureInfo.CurrentCulture, "User {0} doesn't have a dropbox access token", CurrentUser.UserName));

            ms.Seek(0, SeekOrigin.Begin);   // write out the whole stream.  UploadAsync appears to pick up from the current location, which is the end-of-file after writing to a ZIP.

            // The token as provided might be a legacy long-lived one, which we use directly, or a newer JSON authstate, which includes a refresh token.  Start by assuming legacy.
            string szToken = CurrentUser.DropboxAccessToken;

            // if JSonConvert succeeds, then we can read the full authstate, including refreshtoken and expiration date.
            if (szToken.StartsWith("{", StringComparison.OrdinalIgnoreCase))
            {
                try
                {
                    IAuthorizationState auth = JsonConvert.DeserializeObject<AuthorizationState>(szToken);
                    // if here, it deserialized correctly so we can use it.

                    AuthState = auth;

                    await RefreshAccessToken().ConfigureAwait(false);
                    szToken = AuthState.AccessToken;
                }
                catch (JsonException) { }
                catch (DotNetOpenAuth.Messaging.ProtocolException ex) { throw new UnauthorizedAccessException(ex.Message, ex); }
            }

            using (DropboxClient dbx = new DropboxClient(szToken))
            {
                Dropbox.Api.Files.FileMetadata updated = await dbx.Files.UploadAsync(RootPath + szFileName, Dropbox.Api.Files.WriteMode.Overwrite.Instance, body: ms).ConfigureAwait(false);
                return updated;
            }
        }
    }
    #endregion

    #region Google Photo
    [Serializable]
    public class GoogleImageDate
    {
        public int year { get; set; }
        public int month { get; set; }
        public int day { get; set; }

        public GoogleImageDate() { }

        public GoogleImageDate(DateTime dt) : this()
        {
            year = dt.Year;
            month = dt.Month;
            day = dt.Day;
        }
    }

    [Serializable]
    public class GoogleDateFilter
    {
        public IEnumerable<GoogleImageDate> dates { get; set; }

        public GoogleDateFilter()
        {
            dates = new List<GoogleImageDate>();
        }

        public GoogleDateFilter(DateTime dt)
        {
            dates = new GoogleImageDate[] { new GoogleImageDate(dt) };
        }
    }

    [Serializable]
    public class GoogleMediaTypeFilter
    {
        public IEnumerable<string> mediaTypes { get; set; } = new string[] { GoogleMediaType.ALL_MEDIA.ToString() };
    }

    public enum GoogleMediaType { ALL_MEDIA, VIDEO, PHOTO };

    [Serializable]
    public class GoogleImageFilter
    {
        public GoogleDateFilter dateFilter { get; set; }

        public GoogleMediaTypeFilter mediaTypeFilter { get; set; }
    }

    [Serializable]
    public class GoogleImageRequest
    {
        public int pageSize { get; set; }
        public string pageToken { get; set; }
        public GoogleImageFilter filters { get; set; }


        public GoogleImageRequest()
        {
            pageSize = 10;
            pageToken = string.Empty;
            filters = null;
        }
    }

    [Serializable]
    public class GoogleMediaItem
    {
        [JsonProperty("baseUrl")]
        public string baseHref { get; set; }

        public string mimeType { get; set; }
        public string filename { get; set; }

        public GoogleMediaMetaData mediaFileMetaData { get; set; } = null;
    }

    [Serializable]
    public class GoogleMediaMetaData
    {
        public string width { get; set; }

        public string height { get; set; }

        public int Width { get { return int.TryParse(width, NumberStyles.Integer, CultureInfo.InvariantCulture, out int w) ? w : 0; } }

        public int Height { get { return int.TryParse(height, NumberStyles.Integer, CultureInfo.InvariantCulture, out int h) ? h : 0; } }

        public string cameraMake { get; set; }
        public string cameraModel { get; set; }

        public GooglePhotoMetaData photoMetadata { get; set; }

        public GoogleVideoMetaData videoMetadata { get; set; }
    }

    [Serializable]
    public class GooglePhotoMetaData
    {
        public double focalLength { get; set; }
        public double apertureFNumber { get; set; }
        public int isoEquivalent { get; set; }
        public string exposureTime { get; set; }
    }

    [Serializable]
    public class GoogleVideoMetaData
    {
        public double fps { get; set; }
        public string processingStatus { get; set; }
    }

    [Serializable]
    public class GoogleMediaResponse
    {
        public IEnumerable<GoogleMediaItem> mediaItems { get; set; } = Array.Empty<GoogleMediaItem>();
        public string nextPageToken { get; set; }
    }

    #region new google picker data types
    [Serializable]
    public class GPickerMediaResponse
    {
        public IEnumerable<GPickerMediaItem> mediaItems { get; set; } = Array.Empty<GPickerMediaItem>();
        public string nextPageToken { get; set; }
    }

    [Serializable]
    public enum GpickerMediaType { TYPE_UNSPECIFIED, PHOTO, VIDEO }

    [Serializable]
    public class GPickerMediaItem
    {
        public string id { get; set; }
        /// <summary>
        /// Time when the media item was created (not when it was uploaded to Google Photos).
        /// /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
        /// </summary>
        public DateTime? createTime { get; set; }
        public GpickerMediaType type { get; set; }
        public GoogleMediaItem mediaFile { get; set; }

        public async Task<MFBPostedFile> ImportImage(string accessToken)
        {
            Uri uri = new Uri(String.Format(CultureInfo.InvariantCulture, "{0}={1}", mediaFile.baseHref, (mediaFile.mimeType.StartsWith("image/", StringComparison.CurrentCultureIgnoreCase)) ? "d" : "dv"));

            return (MFBPostedFile) await SharedHttpClient.GetResponseForAuthenticatedUri(uri, accessToken, HttpMethod.Get, (response) =>
            {
                string szResult = string.Empty;
                try
                {
                    using (Stream contentStream = response.Content.ReadAsStreamAsync().Result)
                    {
                        return new MFBPostedFile(contentStream, mediaFile.filename, mediaFile.mimeType, (int) contentStream.Length);
                    }
                }
                catch (HttpRequestException ex)
                {
                    if (response == null)
                        throw new MyFlightbookException("Unknown error in GetSession", ex);

                    Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                    GoogleDriveError gde = (d == null || !d.TryGetValue("error", out GoogleDriveError value)) ? null : value;

                    throw new MyFlightbookException(response.ReasonPhrase + " " + (szResult ?? string.Empty));
                }
            });
        }
    }
    #endregion

    [Serializable]
    public class GooglePhotoPollingConfig
    {
        /// <summary>
        /// Output only. Recommended time between poll requests.
        /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        /// </summary>
        public string pollInterval { get; set; }
        /// <summary>
        /// Output only. The length of time after which the client should stop polling.
        /// A value of 0 indicates that the client should stop polling if it hasn't already.
        /// A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        /// </summary>
        public string timeoutIn { get; set; } // 
    }

    [Serializable]
    public class GooglePhotoPickerSession
    {
        public string id { get; set; } = null;

        [JsonProperty(PropertyName = "pickerUri")]
        public string pickerHref { get; set; } = null;

        /// <summary>
        /// Output only. Time when access to this session (and its picked media items) will expire.
        /// A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        /// </summary>
        public string expireTime { get; set; } = null;

        /// <summary>
        /// The recommended configuration that applications should use while polling sessions.get.
        /// This field is only populated if media items have not yet been picked for this session(i.e., mediaItemsSet is false).
        /// </summary>
        public GooglePhotoPollingConfig pollingConfig { get; set; } = null;

        /// <summary>
        /// Output only. If set to true, media items have been picked for this session and your application can request the list of picked media items via mediaItems.list
        /// </summary>
        public bool mediaItemsSet { get; set; } = false;
    }

    public class GooglePhoto : GoogleOAuthBase
    {
        public const string szParamGPhotoAuth = "gPhotoOAuthNew";
        public const string PrefKeyAuthToken = "googlePhotoAuthTokenNew";
        public const string ObsoletePrefKeyAuthToken = "googlePhotoAuthToken";
        private static readonly string[] _gDriveScopes = new string[] { "https://www.googleapis.com/auth/photospicker.mediaitems.readonly" };

        public GooglePhoto(Profile pf = null) : base("GoogleDriveAccessID", "GoogleDriveClientSecret", "https://accounts.google.com/o/oauth2/v2/auth?prompt=consent&access_type=offline", "https://www.googleapis.com/oauth2/v4/token", _gDriveScopes)
        {
            AuthParam = szParamGPhotoAuth;
            CurrentUser = pf;
            AuthState = pf?.GetPreferenceForKey<AuthorizationState>(PrefKeyAuthToken);
        }

        public GooglePhoto(Profile pf, IAuthorizationState authstate) : this(pf)
        {
            AuthState = authstate;
        }

        public async Task<dynamic> GetSession()
        {
            string szResult = string.Empty;
            try
            {
                if (await RefreshAccessToken().ConfigureAwait(false) && CurrentUser != null)
                    CurrentUser.SetPreferenceForKey(PrefKeyAuthToken, AuthState);
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException)
            {
                return null;
            }

            GooglePhotoPickerSession sess = new GooglePhotoPickerSession();

            using (StringContent sc = new StringContent(JsonConvert.SerializeObject(sess), System.Text.Encoding.UTF8))
            {
                sc.Headers.ContentType = new MediaTypeHeaderValue("application/json") { CharSet = "UTF-8" };
                return await SharedHttpClient.GetResponseForAuthenticatedUri(new Uri("https://photospicker.googleapis.com/v1/sessions"), AuthState.AccessToken, HttpMethod.Post, sc, (response) =>
                {
                    try
                    {
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        GooglePhotoPickerSession gpsess = JsonConvert.DeserializeObject<GooglePhotoPickerSession>(szResult);
                        return new { sess = gpsess, token = AuthState.AccessToken };
                    }
                    catch (HttpRequestException ex)
                    {
                        if (response == null)
                            throw new MyFlightbookException("Unknown error in GetSession", ex);

                        Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                        GoogleDriveError gde = (d == null || !d.TryGetValue("error", out GoogleDriveError value)) ? null : value;

                        throw new MyFlightbookException(response.ReasonPhrase + " " + (szResult ?? string.Empty));
                    }
                });
            }
        }
    }
    #endregion
}